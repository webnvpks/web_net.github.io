<title>Оптимизация использования памяти. Оптимизация использования жесткого диска. Оптимизация использования сети.
    Инструменты повышения производительности программного обеспечения.</title>
<link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="../../css/css.css">
<meta charset="utf-8">
<script src="../../js/jquery-3.3.1.min.js"></script>
<script src="../../js/vision_js.js"></script><script src="../../js/slide_js.js"></script>
<div class="body">
    <p class="vision" title="Версия для слабовидящих" onclick="cl()">
        <svg width="50" height="50" viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
            <path fill="#ffffff"
                d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
            </path>
        </svg>
    </p>
</div>
<div class="header"></div>
<div class="hat"><div class="sandwich" onclick="OpenMenu()">>>></div>
    <p class="name">
        Внедрение и поддержка компьютерных систем
    </p>
    <div class="links">
        <a href="../../../index.html" class="link">Главная</a>
        <a href="../lectures.html" class="link" title="Лекции">Лекции</a>
        <a href="../video.html" class="link" title="Видео-уроки">Видео-уроки</a>
        <a href="../laboratornie.html" class="link" title="Лабораторные работы">Лабораторные работы</a>

    </div>
</div>
<div class="content">
    <h1>Оптимизация использования памяти. Оптимизация использования жесткого диска. Оптимизация использования сети.
        Инструменты повышения производительности программного обеспечения.</h1>
    <h2>Оптимизация использования оперативной памяти</h2>
    <p>Оптимизация использования памяти может преследовать две цели &ndash; увеличение объема памяти, доступной
        приложениям, и повышение быстродействия обращений к памяти. На старых машинах, когда объем установленной
        физической памяти не превышал единиц мегабайт, зачастую приходилось чем-то жертвовать; в современных системах
        достижение обеих целей уже не противоречит друг другу. Нет сомнений в том, что, чем больше установленный объем
        ОЗУ, тем лучше &ndash; компьютер будет мощнее: он позволит загружать приложения, особо &laquo;жадные&raquo; до
        памяти; увеличить число одновременно работающих приложений (в многозадачной ОС); ускорить работу. Однако для
        обеспечения возможности использования памяти в ряде случаев требуются некоторые дополнительные действия по
        конфигурированию компьютера.&nbsp;<br />В системах с размером установленной памяти более 640 Кбайт возможны
        различные варианты использования последних 384 Кбайт из первого мегабайта физической памяти:</p>
    <ul>
        <li>память не используется;</li>
        <li>область (или часть ее) перемещается в конец дополнительной памяти;</li>
        <li>область (или часть ее) используется в качестве теневой&nbsp;<em>(Shadow)&nbsp;</em>памяти адаптеров и ROM
            BIOS.</li>
    </ul>
    <p><br />Перемещение неиспользуемого остатка первого мегабайта в конец дополнительной памяти (разрешается установкой
        параметра Memory Relocation в CMOS Setup) возможно не всегда. Обычно такое перемещение становится невозможным,
        если хоть часть из этого кусочка используется в качестве теневой памяти.&nbsp;<br />Также перемещение может
        предлагаться лишь при небольших объемах установленной памяти, и на современных системных платах эта возможность
        почти не встречается. Поэтому не стоит удивляться сообщению об объеме памяти, обнаруженном тестом POST, в
        котором относительно установленного &laquo;не хватает&raquo; 384 Кбайт.&nbsp;<br />Иногда BIOS предлагает такое
        распределение памяти, при котором под стандартную память выделяются 512 Кбайт, а остальная память идет как
        расширенная. Пользу такого распределения оценить трудно. При этом вышесказанное про верхние 384 Кбайт становится
        справедливым для оставшихся 512 Кбайт, правда, на возможность их перемещения в конец дополнительной памяти
        ограничения будут мягче.&nbsp;<br />Острее всего проблема обеспечения доступности памяти стоит для приложений
        MS-DOS, исполняемых в среде этой системы. Обычно &laquo;битва&raquo; идет за килобайты стандартной памяти
        (conventional memory), доступной приложениям. Из 640 Кбайт после загрузки ОС и необходимых резидентных драйверов
        на долю приложений может остаться около 500 Кбайт, а то и меньше, что для ряда приложений неприемлемо. Несмотря
        на повсеместное внедрения ОС типа Windows 9х, интерес к запуску больших приложений MS-DOS (например,
        бухгалтерских программ, в том числе и принудительно распространяемых налоговыми органами, а также игр)
        сохраняется и поныне. Сообщение о нехватке памяти на компьютере с ОЗУ размером, например, 32 Мбайт для
        приложения, скромно просящего всего 590 Кбайт, неприятно удивляет неискушенных пользователей. Однако эта
        нехватка не фатальна, если правильно выбрать версию и способ загрузки ОС. Все программные настройки, влияющие на
        объем доступной памяти, кроются в файлах CONFIG.SYS и AUTOEXEC.BAT, размещенных в корневом каталоге загрузочного
        диска.&nbsp;<br />Понимая проблемы, возникающие в связи с использованием памяти различными процессорами, для
        DOS-приложений можно рекомендовать следующие версии MS-DOS, оптимальные по размеру свободной стандартной памяти:
    </p>
    <ul>
        <li>для компьютеров класса XT на процессорах 8086/88 &ndash; MS-DOS 3.30;</li>
        <li>для компьютеров класса AT на процессорах 80286 &ndash; MS-DOS 5.x;&nbsp;&nbsp;</li>
        <li>для компьютеров класса AT на процессорах 80386 и выше &ndash; MS-DOS 6.2x (правда, одно время встречались
            некачественные системные платы для 80386, на которых MS-DOS 6.2x отказывалась загружаться в НМА, хотя MS-DOS
            5.x работала нормально).</li>
    </ul>
    <p><br />Кроме MS-DOS, существуют и другие операционные системы реального режима, совместимые с MS-DOS (например, PC
        DOS, DR DOS, COMPAQ DOS). Каждая из них имеет свои преимущества и недостатки по сравнению с соответствующим
        поколением MS-DOS, но их обсуждение выходит за рамки данного пособия. Операционные системы (и оболочки)
        защищенного режима на компьютеры с процессором класса ниже 386 пытаться устанавливать почти бессмысленно.
        Система MS-DOS 3.3 (более ранние рассматривать не будем) загружалась целиком в стандартную память, но была
        довольно компактной и оставляла приемлемое место для приложений своего времени. Когда вышла MS-DOS версии 4 с
        более развитыми возможностями, появившимися ценой ее разрастания, многие приложения отказывались работать в ее
        среде именно из-за нехватки памяти, и эта версия ОС широкого распространения не получила. Более удачной стала
        версия 5, которая &laquo;научилась&raquo; использовать &laquo;высокую память&raquo; (НМЛ) на компьютерах с
        процессором 286 и выше, если таковая присутствовала. Для этого был введен специальный драйвер высокой памяти, и
        в файле CONFIG.SYS должны присутствовать строки:&nbsp;<br />DEVICE=[&lt;path&gt;]HIMEM.SYS (загрузка драйвера
        высокой памяти)&nbsp;<br />DOS=HIGH (указание на загрузку ОС в высокую память)&nbsp;<br />Конечно, в верхнюю
        память загружается не вся ОС &ndash; часть все-таки попадает и в стандартную память. Кроме того, в стандартную
        память загружаются и резидентные драйверы &ndash; например, русификаторы клавиатуры и экрана, драйвер мыши и т.
        п. Все они отрывают свой кусок от памяти, которую могли бы использовать приложения. На компьютерах с
        32-разрядными процессорами (386 и выше), имеющих механизм страничной переадресации, появилась возможность
        использования &laquo;верхней памяти&raquo; (UMA) с помощью драйвера EMM386.EXE. Этот драйвер отыскивает в
        области UMA (A0000-FFFFFh) регионы, не занятые памятью устройств, и отображает их на области доступной
        дополнительной памяти. В эти регионы, нормально адресуемые процессором в реальном режиме, можно помещать модули
        операционной системы и загружаемые драйверы; их же могут использовать и приложения.&nbsp;<br />Для наиболее
        компактной загрузки MS-DOS версий 5 и выше (а также Windows 9х, которая может представляться как MS-DOS 7) в
        файле CONFIG.SYS должны быть следующие директивы:&nbsp;<br />DEVICE=[&lt;path&gt;]HIMEM.SYS&nbsp;&nbsp;
        (загрузка драйвера&nbsp; высокой&nbsp; памяти);&nbsp;<br />DEVICE=[&lt;path&gt;]EMM386.EXE&nbsp;&nbsp; (загрузка
        диспетчера&nbsp; расширенной&nbsp; памяти);&nbsp;<br />DOS=HIGH.&nbsp;&nbsp; UMB&nbsp;&nbsp; (указание&nbsp;
        на&nbsp; загрузку ОС в высокую и&nbsp; верхнюю память).&nbsp;<br />Резидентные драйверы (русификаторы
        клавиатуры, экрана и принтера, драйвер мыши) по умолчанию обычно загружаются в стандартную память. Если
        приложениям MS-DOS не хватает свободной памяти, то, по крайней мере, часть резидентных драйверов можно загрузить
        в верхнюю память UMA. Для драйверов, загружаемых из файла CONFIG.SYS, вместо команды DEVICE&raquo; следует
        использовать команду DEVICEHIGH [/L:n[,m]]=, которая попытается загрузить драйвер в n-регион UMB. Необязательный
        параметр m задает требуемый объем памяти (он может отличаться от размера файла с драйвером). Ключ загрузки /L
        вместе с параметрами n, m используется для ручной оптимизации памяти. Если драйверу требуется выделить несколько
        областей памяти, то они перечисляются в списке вида /L:nl[,ml]:n2[,m2][;...]. Для резидентных программ,
        загружаемых из файла AUTOEXEC.BAT, тем же целям служит команда LOADHIGH (LH) с аналогичными необязательными
        параметрами, задающими размер одной или нескольких областей UMA. Строка запуска будет иметь
        вид:&nbsp;<br />LH[/L:n[,m]]&nbsp;&nbsp; &lt;путь\&gt;&lt;файл&gt;[&lt;параметры&gt;]&nbsp;<br />Посмотреть
        текущее положение свободных блоков памяти можно командой MEM/F из командной строки DOS/Windows. Чтобы не
        заниматься ручной оптимизацией памяти, в состав DOS/Windows введена диалоговая утилита MEMMAKER.EXE, которая за
        несколько этапов расставит требуемые команды в файлах CONFIG.SYS и AUTOEXEC.BAT. До ее запуска в этих файлах
        должны присутствовать ссылки на все необходимые драйверы и программы. Файл CONFIG.SYS должен начинаться с
        вышеприведенных трех строк (если не указать DOS=HIGH, утилита может &laquo;постесняться&raquo; использовать
        высокую память для загрузки DOS). Запуск нерезидентных приложений, а также оболочки типа Norton Commander из
        файла AUTOEXEC.BAT на время работы MEMMAKER следует отменить (MEMMAKER несколько раз перезагружает компьютер и
        автоматически запускается после отработки файла AUTOEXEC.BAT). При начальном запуске MEMMAKER спрашивает,
        требуется ли память EMS для приложений, и, если нет, то установит ключ NOEMS в строке запуска
        EMM386.&nbsp;<br />Для того чтобы в верхнюю память поместилось как можно больше модулей, ее следует
        оптимизировать. Оптимизация UMA подразумевает такое конфигурирование базовых адресов буферной и постоянной
        памяти адаптеров, при котором свободные области UMA получались бы максимально возможного размера. Нужно
        стремиться к плотному соединению областей UMA, занимаемых адаптерами. Тогда максимальный размер блоков UMB
        увеличится, и драйвер типа EMM386 сможет разместить в нем более крупные модули, что, в свою очередь, позволит
        освободить дополнительное место в остродефицитной стандартной памяти. Если на конфигурирование адаптеров не
        обращать внимания, то может оказаться, что два компьютера с одинаковым составом аппаратных средств и программным
        обеспечением будут после загрузки ОС иметь значительно различающиеся размеры стандартной
        памяти.&nbsp;<br />Многие адаптеры (контроллеры SCSI, адаптеры локальных сетей и др.) позволяют задавать адреса
        областей встроенных RAM и ROM, отображаемых в пространство памяти компьютера. Это позволяет разрешать (или,
        наоборот, создавать) конфликты использования UMA, а также оптимизировать использование ее блоков. При
        конфигурировании устанавливаемых адаптеров необходимо исключить перекрытия занимаемых адресов, поскольку из-за
        этого, скорее всего, ни одно из конфликтующих устройств работать не будет. Самый неприятный (трудно устранимый)
        конфликт возникает, если при конфигурировании какого-либо адаптера его память перекрывает буфер или BIOS
        графического адаптера. Если конфигурирование осуществляется джамперами, то вернуть нормальную конфигурацию труда
        не составит. А если адаптер конфигурируется только с помощью специальной утилиты, изменяющей содержимое его
        энергонезависимой памяти, то изменить его конфигурацию можно, лишь загрузив и выполнив соответствующую утилиту.
        Но при конфликте с графическим адаптером это сделать не так-то просто &ndash; в лучшем случае удастся загрузить
        компьютер со &laquo;слепым&raquo; экраном, а в худшем &ndash; POST откажется продолжать тестирование и загрузку,
        обнаружив ошибку графического адаптера и сообщив об этом попискиванием динамика. Но эта ситуация не так
        безнадежна: есть еще в природе графический адаптер MDA, у которого видеобуфер не совпадает по адресам
        сраспространенными адаптерами EGA и VGA, а расширение BIOS у него отсутствует. Вставив неудачно
        сконфигурированную плату в компьютер с адаптером MDA (и, конечно, соответствующим монитором), можно утилитой
        задать правильную конфигурацию. Однако этот способ для новых компьютеров, не имеющих слотов шины ISA, уже
        непригоден.&nbsp;<br />Кроме занимаемого пространства, оптимизация использования UMA касается, как ни странно, и
        быстродействия. Для областей памяти адаптеров часто бывает полезным применение теневой памяти. Управление
        теневой памятью осуществляется через CMOS Setup для определенных областей. Поэтому, размещая конфигурируемые
        области памяти, иногда следует учитывать возможности задания границ теневой памяти в CMOS Setup. Необходимо
        помнить, что Shadow ROM блокирует запись, a Shadow RAM игнорирует возможность изменения со стороны адаптера
        затеняемой области памяти, что приведет к ошибкам при некорректном использовании теневой памяти. Для процессоров
        386 и выше теневую память может организовать и драйвер EMM386, но этой его функцией пользуются
        редко.&nbsp;<br />Работу приложений в среде MS-DOS, в которой активно используется программный код BIOS,
        значительно ускоряет затенение ROM BIOS, как системной, так и BIOS графического адаптера и дискового
        контроллера. Для многозадачных ОС защищенного режима (Windows и др.) затенение ROM BIOS ускоряет только
        начальный процесс загрузки ОС, поскольку в рабочем режиме здесь в основном используются драйверы, загружаемые в
        ОЗУ.&nbsp;<br />Приложения ОС Windows пользуются&nbsp;<em>виртуальной памятью</em>,и никакие старые спецификации
        EMS и XMS им не нужны. Суммарный объем виртуальной памяти, доступной всем приложениям, определяется размером ОЗУ
        и файлов подкачки (их может быть и несколько). В Windows 9x размер файла подкачки изменяется динамически, по
        мере потребностей системы. Для того чтобы приложениям хватало памяти, на диске, несущем файл подкачки, должно
        быть достаточно свободного пространства (десятки и сотни мегабайт). Конечно же, важен и объем установленной
        физической памяти &ndash; ее малый объем может быть принципиальным ограничением на запуск ряда приложений или
        установку операционных систем. При малом объеме ОЗУ свопинг (подкачка страниц) будет слишком интенсивным, в
        результате чего скорость работы приложений существенно снижается (обращения к диску выполняются на несколько
        порядков медленнее, чем к ОЗУ). Приложения реального времени (например, аудио- и видеопроигрыватели и тем более
        кодеры) могут стать неработоспособными именно из-за малого объема ОЗУ. Поскольку файл подкачки изменяет свой
        размер в процессе работы, важно следить за фрагментацией диска, несущего этот файл &ndash; обращение к
        фрагментированному файлу выполняется медленнее, чем к нефрагментированному. При выборе диска для размещения
        файла подкачки следует учитывать его быстродействие &ndash; время доступа и скорость передачи данных. При
        использовании приложений реального времени, интенсивно обменивающихся с дисками (те же проигрыватели и кодеры, а
        также программы, записывающие компакт-диски), по возможности файл подкачки следует размещать на других
        дисках.&nbsp;<br />Если на компьютере под управлением ОС защищенного режима (Windows, Unix, OS/2...) перестают
        запускаться приложения с сообщениями о недостаточном объеме оперативной памяти &ndash; проверьте наличие
        свободного места на жестких дисках, используемых для подкачки. Если памяти не хватает приложениям MS-DOS &ndash;
        проверьте файлы AUTOEXEC.BAT и CONFIG.SYS и запустите утилиту MEMMAKER или выполните ручную оптимизацию
        памяти.&nbsp;<br />Увеличение физического объема оперативной памяти в ряде случаев может привести к неожиданному
        снижению производительности компьютера. Это возможно, когда системная плата (или процессор со вторичным кэшем)
        не способна кэшировать весь объем ОЗУ. У многих системных плат для процессоров Pentium кэшируются только первые
        64 Мбайт ОЗУ; у первых процессоров Pentium II кэшировались только 512 Мбайт. Память, выходящая за размеры
        кэшируемой области, конечно же, доступна, но ее производительность гораздо ниже кэшируемой. ОС Windows 9x
        распределяет память, начиная с верхней границы доступной памяти, причем наверх попадает ее ядро, скорость работы
        которого существенна для работы многих приложений. Если после увеличения ОЗУ ядро попадает в некэшируемую
        область, можно наблюдать снижение производительности. Для лечения этого недуга можно воспользоваться
        условно-бесплатной программой W2CACHE.COM, которая запускается в начале загрузки Windows и, оставаясь
        резидентной, &laquo;съедает&raquo; верхнюю часть памяти, заставляя ядро Windows загружаться в нижнюю, кэшируемую
        область. После окончания загрузки Windows программа освобождает занимаемую память, и ОС отдает ее в распоряжение
        приложений.</p>
    <h2>Оптимизация и ускорение работы жесткого диска</h2>
    <p>Наверно все пользователи хотят, чтобы их компьютеры могли выполнять требуемые действия намного быстрее, чем в
        текущий момент. Процесс обработки информации можно ускорить разными способами. К подобным вариантам относится
        оптимизация работы винчестера. Для подобного процесса в Виндовс имеется огромное количество настроек и
        инструментов. Давайте рассмотрим, как ускорить работу жесткого диска и в целом работу компьютера.</p>
    <h3><span>Отключение индексирования</span></h3>
    <p>Данный способ подойдет для тех, кто не использует функцию поиска в операционной системе.</p>
    <p>Основой метода является закрытие раздела винчестера от индексирования, что обеспечит ускорение его работы. Для
        этого:</p>
    <ol>
        <li>Переходим в &laquo;Мой компьютер&raquo;. Там нужно вызвать контекстное меню на главном диске, зачастую это
            диск С:\. Затем нажимаем &laquo;Свойства&raquo;.</li>
        <li>В меню &laquo;Общие&raquo; выбираем пункт &laquo;Разрешить индексировать содержимое&hellip;&raquo;. Нужно
            снять галочку и подтвердить действие.</li>
        <li>После данных действий появится оповещение, где будет сообщаться про возможность использования новой политики
            только к определенным файлам. Выбираем &laquo;Продолжить&raquo;, а затем &laquo;Пропустить все&raquo;.</li>
    </ol>
    <h3><span>Отказываемся от ведения журнала</span></h3>
    <p>В стандартных настройках в системе имеется функция ведения журнала. Там отображаются все сбои и произведенные
        изменения. Если данную систему Вы не используете или даже не понимаете, что это значит, то можете смело ее
        отключить.</p>
    <p>Инструкция по отключению:</p>
    <ol>
        <li>Запуск командной строки. Наиболее простейший способ: нажатие &laquo;Win+R&raquo;, а в появившемся окне
            &laquo;Выполнить&raquo; ввести &laquo;cmd&raquo;.</li>
        <li>Откроется приложение, где требуется ввести: fsutil usn deletejournal /D С:, где С &ndash; это буква
            необходимого жесткого диска.</li>
        <li>Для подтверждения своих намерений нужно нажать на &laquo;Enter&raquo;. Затем командную строку необходимо
            закрыть.</li>
        <li>Для вступления в силу изменений, компьютер необходимо перезагрузить.</li>
    </ol>
    <h3><span>Очистка от ненужных файлов</span></h3>
    <p>Довольно часто показатели скорости работы жестких дисков заметно улучшаются после удаления ненужных файлов,
        которые за длительное время могли собраться на накопителе. Чем больше свободного пространства на винчестере, тем
        быстрее будет происходить поиск файлов, а это ускорит работу.</p>
    <p>Если этот процесс рассмотреть более подробно, то получается, что система не будет производить долгий поиск в
        своих таблицах адреса определенных единиц информации. При удалении не нужных данных количество таких таблиц
        уменьшится, чем при заполненном пространстве.</p>
    <p>Поэтому нужно чаще удалять файлы с компьютера, которые не используются. Если они важные, то можно просто их
        собрать в одну папку и заархивировать. Подобная процедура освободит место, а в параметрах основной таблицы будет
        только один адрес.</p>
    <p>Чтобы очистить диски в Виндовс 7 и иных версиях, используются специальные инструменты. Они располагаются в меню
        &laquo;Пуск&raquo; в категории служебных программ. Точное название &ndash; &laquo;Очистка диска&raquo;.
        Программа производит поиск неиспользуемых файлов в разделе, а затем предлагает пользователю их удалить.</p>
    <p>Кроме этого существует большое количество программ, обеспечивающих проведение данной процедуры.</p>
    <h3><span>Дефрагментация</span></h3>
    <p>Когда производится запись новой информации на устройство, она не всегда размещается рядом. Размещение отдельных
        пакетов производится по свободному месту тома. После проведения многочисленных записей, одни файл может быть
        расположен по всему носителю. Это приводит к тому, что система постоянно обращается к разным секторам. Используя
        дефрагментацию, можно искать подобные данные и собирать их вместе. Затем система будет обращаться к соседним
        местам, что увеличит скорость работы.</p>
    <p>Подобный инструмент способен помочь только при использовании HDD дисков.</p>
    <p>Функция имеется в различных программах, которые предлагают сервисы по ускорению работы компьютера.</p>
    <p>Операционные системы от Microsoft имеют возможность проводить дефрагментацию с использованием встроенных
        возможностей. Для этого в &laquo;Компьютере&raquo; необходимо выбрать необходимый диск и произвести запуск
        контекстного меню. Затем выбирается &laquo;Свойства&raquo;, там пункт &laquo;Сервис&raquo; и указать
        &laquo;Оптимизировать&raquo;. Затем ОС предложит выполнить дефрагментацию.</p>
    <h3><span>Переразметка</span></h3>
    <p>В случаях, когда компьютер используется длительное время и работает винчестер на полную мощностью, можно
        произвести переразметку. Это поможет при наличии двух и более разделов.</p>
    <p>Это форматирование диска, а некоторые разработчики указывают, что заново &laquo;режется&raquo; жесткий диск на
        сектора и дорожки.</p>
    <p>Идеальным является вариант, когда в системе применяется один жесткий диск с единственным томом. Нормальной
        считается система с двумя разделами. При большем количестве &ndash; система будет более медленно работать, тратя
        время на поиск необходимых файлов. В данном процессе поиск осуществляется по всем жестким дискам поочередно.
        Можно один жесткий диск использовать для установки ОС и софта, на другой записывать фильмы и прочие
        мультимедийные файлы.</p>
    <h3><span>Перемещение файлов на съемный носитель</span></h3>
    <p>Неплохим вариантом считается перемещение неиспользуемых данных на отдельные носители. Зачастую для этого
        применяются внешние накопители. Важно выбирать надежные внешние HDD, которые будут отличаться высокой скоростью
        обработки информации.</p>
    <p>Изделия можно использовать не только для хранения устаревших файлов, но и в виде флешки. Для подобных целей 500
        Гб будет достаточно. С компьютером он соединяется по USB интерфейсу и отличается бесшумной работой.</p>
    <h3><span>Отключение автозагрузки программ</span></h3>
    <p>Наличие лишних программ в автозагрузке существенно замедляет работу компьютера и использует его процессор и
        память. Если их отключить, то можно увеличить скорость работы диска и в целом производительность системы.</p>
    <p>В разных версиях Виндовс управление автозагрузкой располагается в разных местах. Наиболее удобно для подобной
        цели использовать утилиту &laquo;CCleaner&raquo;. Требуется осуществить запуск утилиты и перейти в меню
        &laquo;Сервис/Автозагрузка&raquo;.</p>
    <p>В автозагрузке нужно оставить только те программы, которые нужны для работы компьютера, например, антивирус.
        Остальные компоненты можно отключить кнопкой &laquo;Выключить&raquo; в правой панели.</p>
    <p>Любую из отключенных программ можно всегда снова запустить вручную. Если пропадет значок в системном трее, то ее
        запуск можно вернуть с использованием кнопки &laquo;Включить&raquo;.</p>
    <h3><span>Обновление драйвера контроллера диска</span></h3>
    <p>От актуальности драйверов зависит стабильность всей системы. Рекомендуется обновлять драйверы до новейшей версии,
        особенно это касается SSD дисков.</p>
    <p>Для проверки версии установленных драйверов нужно зайти в &laquo;Диспетчер устройств&raquo;. Необходимо вызвать
        командную строку, а в ней ввести &laquo;devmgmt.msc&raquo; и нажать &laquo;Enter&raquo;. Затем нажать правой
        кнопкой мыши по SATA контроллеру и выбрать пункт &laquo;Свойства&raquo;.</p>
    <p>Если используется старый драйвер, то новый можно найти на официальном сайте производителя системной платы или
        ноутбука, скачать и обновить его.</p>
    <p>Существуют специальные утилиты, которые позволяют обновить драйверы. Можно выбрать софт &laquo;Driver
        Booster&raquo;, который при запуске покажет список драйверов, для которых требуется обновление.</p>
    <p>Данная информация поможет Вам оптимизировать жесткий диск и повысить его работоспособность.</p>
    <h2>Способы увеличения быстродействия программ</h2>
    <p>Современные ЭВМ обладают очень большой мощностью. Скорость работы процессора (ЦП) современных ЭВМ измеряется
        гигагерцами, объём оперативной памяти гигабайтами, а современные интерфейсы устройств обеспечивают скорость
        обмена данными порядка, как минимум, нескольких сотен мегабайт в секунду. Производительность, которая ещё
        несколько лет назад казалась &laquo;сказочной&raquo; в настоящее время стала нормой жизни.</p>
    <p>Однако параллельно росту мощности ЭВМ увеличивается и ресурсоёмкость приложений. У приложений совершенствуется
        функционал, интерфейс, возрастает объём обрабатываемых данных и как следствие системные требования. Поэтому
        вопрос об увеличении быстродействия приложений не теряет своей актуальности.<span></span></p>
    <p><strong>Общие вопросы быстродействия программ.</strong></p>
    <p>Быстродействие программ (ПО) зависит от многих факторов, но основными из них являются два:</p>
    <ul>
        <li>Соотношение между реальными системными требованиями ПО и существующей аппаратной конфигурацией ЭВМ;</li>
        <li>Алгоритмы работы ПО.</li>
    </ul>
    <p>Если низкое быстродействие обусловлено первым фактором, то решением является модернизация аппаратной части
        (hardware). В некоторых случаях проблему можно решить также с помощью тонкой настройки hardware и операционной
        системы. Однако этот путь имеет ряд недостатков:</p>
    <ol>
        <li>Увеличивается производительность hardware, а вовсе не быстродействие ПО;</li>
        <li>Производительность hardware ограничена возможностями существующих в данный момент элементной базы и
            инженерных решений в данной области;</li>
        <li>Большие финансовые затраты на модернизацию и настройку по причине высокой стоимости комплектующих ЭВМ и
            услуг специалистов требуемой квалификации.</li>
    </ol>
    <p>По этим причинам при разработке ПО прибегают к увеличению его быстродействия с помощью различных средств
        программной инженерии. Это позволяет:</p>
    <ol>
        <li>Обеспечить работу нового ПО на уже существующем оборудовании;</li>
        <li>Разработать масштабируемое ПО;</li>
        <li>Значительно уменьшить финансовые и трудовые затраты при внедрении.</li>
    </ol>
    <p>Вместе с тем и у этого пути имеется ряд недостатков:</p>
    <ol>
        <li>Значительно усложняется процесс разработки ПО, так как более &laquo;быстрые&raquo; алгоритмы сложнее более
            &laquo;медленных&raquo; (на пример алгоритм бинарного поиска сложнее, чем алгоритм линейного поиска);</li>
        <li>Реализация более сложных алгоритмов, как правило, требует привлечения специалистов более высокой
            квалификации;</li>
        <li>В случае работы с большими объёмами данных или выполнении задач требующих больших и сложных вычислений,
            ресурсоёмкость ПО всё равно остаются достаточно высокой. Несмотря, на какие либо способы увеличения
            быстродействия.</li>
    </ol>
    <p>Таким образом, в общем случае обеспечение быстродействия ПО является комплексной задачей.</p>
    <p>Однако следует заметить, что среди существующих задач, очень немногие обладают высокой ресурсоёмкостью.
        Вследствие этого в большинстве случаев не требуется никаких действий относительно hardware и требуемого
        результата можно достичь, прибегая только к программной инженерии.</p>
    <p>Программная инженерия предоставляет несколько способов увеличения быстродействия программ. Рассмотрим их на
        примере языков программирования Delphi и Assembler.</p>
    <p><strong>Увеличение быстродействия программ.</strong></p>
    <p>Как было показано в предыдущем параграфе, можно увеличить быстродействие ПО соответствующим образом реализовав
        его алгоритмы. Количественным показателем быстродействия алгоритма (а, следовательно, и ПО) является время его
        выполнения, измеренное по специальной методике, так называемого профилирования. Таким образом, в общем случае
        выбор наиболее &laquo;быстрых&raquo; алгоритмов сводится к измерению времени их выполнения и сравнении
        полученных результатов между собой. Такой способ анализа быстродействия является наиболее объективным. На
        протяжении многих лет программистами был накоплен большой опыт профилирования, который позволяет сделать
        определённые выводы относительно возможности оптимизации быстродействия ПО ещё на стадии написания.</p>
    <p>Эти выводы были обобщены и представлены в виде определённых рекомендаций. Если программист будет следовать данным
        рекомендациям, то написанная программа вероятнее всего будет обладать большим быстродействием, чем в случае их
        игнорирования. Однако следует ещё раз подчеркнуть, что достоверные сведения о быстродействии может дать только
        профилирование. Это обусловлено тем, что быстродействие алгоритма определяет в первую очередь его конкретная
        реализация. Кроме того необходимо ещё раз отметить, что в отношении увеличения быстродействия ПО программная
        инженерия не всесильна.</p>
    <p>В чём же состоят выше упомянутые рекомендации? Их краткое содержание применительно к языку программирования
        Delphi приведено ниже.</p>
    <ol>
        <li>При написании кода программ рекомендуется избегать процедур, состоящих из сотен строк. Практически всегда в
            них можно выделить блоки, которые лучше оформить в виде отдельной процедуры. Возможно, позже вы ей даже
            воспользуетесь где-то в другом месте. Не говоря уже о том, что это повышает понимание программы и вами, и
            другими программистами. К тому же так проще искать &laquo;узкие&raquo; места в программе.</li>
        <li>Использование оператора case (switch) вместо многократных if&hellip; then&hellip; else (if&hellip; else). Во
            втором варианте компилятор будет выполнять проверку условия столько раз, сколько у вас вариантов. В первом
            проверка выполняется лишь однажды.</li>
        <li>Некоторые действия могут быть довольно продолжительными, поэтому рекомендуется выносить за рамки цикла всё,
            что можно выполнить вне его, чтобы избежать большого числа повторений внутри цикла.</li>
        <li>В циклах типа for нужно стараться, чтобы значение счетчика уменьшалось до нуля, а не наоборот &mdash;
            начиналось с нуля. Это связано с особенностями процессора. Сравнение с нулём выполняется гораздо быстрее,
            чем с другим числом.</li>
        <li>Пользоваться типом Variant только при необходимости. Операции над этим типом сложнее, чем, например, над
            Integer или String.</li>
        <li>Не злоупотреблять &laquo;программированием на компонентах&raquo;. В частности не использовать компонент
            TTreeView для хранения древовидных структур данных &mdash; он работает очень медленно и предназначен только
            для визуального отображения. В случае работы со структурами данных лучше использовать алгоритмы, созданные
            самостоятельно на основе фундаментальных.</li>
        <li>Сохранение и загрузка свойств компонентов с помощью методов ReadComponent и WriteComponent работает довольно
            медленно, поэтому по возможности рекомендуется сохранять и восстанавливать состояние программы между
            сеансами при помощи других способов.</li>
        <li>Заменить простой в реализации алгоритм на более сложный, но с большим быстродействием. Например, если
            заранее известно, что в списке для поиска будет много элементов, лучше его отсортировать и применять
            бинарный поиск вместо линейного.</li>
        <li>В критических с точки зрения быстродействия местах программы делать вставки на ассемблере. Команды
            ассемблера напрямую транслируются в машинный код. Таким образом, в отличие от высокоуровневых языков при
            компиляции отсутствует проблема синхронизации и ряд других негативных обстоятельств.</li>
    </ol>
    <p>Для других языков программирования вышеприведённый список может несколько отличаться, в частности отсутствием
        поддержки ассемблера и как следствие возможности оптимизации с его помощью (Java, Visual C# и др.).</p>
    <p>Особо следует отметить, что рекомендации 3 и 4 применяются не только для языков высокого уровня, но и для
        ассемблера. Помимо вышеуказанных для увеличения быстродействия программ написанных на ассемблере, в том числе и
        вставок, существуют следующие рекомендации:</p>
    <ol>
        <li>Замещение универсальных инструкций на учитывающие конкретную ситуацию, например, замена умножения на степень
            двойки на команды сдвига (отказ от универсальности).</li>
        <li>Уменьшение количества передач управления в программе: за счет преобразования подпрограмм в макрокоманды для
            непосредственного включения в машинный код; за счет преобразования условных переходов так, чтобы условие
            перехода оказывалось истинным значительно реже, чем условие для его отсутствия; перемещение условий общего
            характера к началу разветвленной последовательности переходов; преобразование вызовов, сразу за которыми
            следует возврат в программу, в переходы (&laquo;сращивание хвостов&raquo; и &laquo;устранение рекурсивных
            хвостов&raquo;) и т.д.</li>
        <li>Максимальное использование всех доступных регистров за счет хранения в них рабочих значений всякий раз,
            когда это возможно, чтобы минимизировать число обращений к памяти, упаковка множественных значений или
            флагов в регистры и устранение излишних продвижений стека (особенно на входах и выходах подпрограмм).</li>
        <li>Использование специфических для данного процессора инструкций, например, инструкции засылки в стек
            непосредственного значения, которая имеется в процессоре 80286 и более поздних. Другие примеры &ndash;
            двухсловные строковые инструкции, команды перемножения 32-разрядных чисел, деление 64-разрядного на
            32-разрядное число и умножение на непосредственное значение, которые реализованы в процессорах 80386 и
            80486. Программа должна, разумеется, вначале определить, с каким типом процессора она работает!</li>
    </ol>
    <p><strong>Заключение.</strong></p>
    <p>Методы оптимизации быстродействия, рассмотренные в этой статье, были выработаны и проверены не одним поколением
        программистов и уже стали классическими. В то же время информационные технологии, в частности технологии
        программирования, постоянно развиваются. Появляются новые технологии, старые &ndash; модернизируются или уходят
        в прошлое. Растёт производительность аппаратной части ЭВМ и параллельно с этим растёт сложность и ресурсоёмкость
        выполняемых ими задач.</p>
    <div class="next"><a href="zagruzka_i_ustanovka_programmnogo_obespecheniya13.html">Следующая лекция</a></div>
</div>
<div id="vis">
    <div class="font">
        Размер шрифта:</div>
    <div class="fontA" onclick="fonta()">А</div>
    <div class="fontAA" onclick="fontaa()">А</div>
    <div class="fontAAA" onclick="fontaaa()">А</div>
    <div class="color">Цвет сайта:</div>
    <div class="colorW" onclick="clwhite()">A</div>
    <div class="colorBK" onclick="clblack()">A</div>
    <div class="colorBE" onclick="clblue()">A</div>
    <div class="imgOnOff">Изображение:</div>
    <div class="imgOn" onclick="imgon()">Вкл.</div>
    <div class="imgOff" onclick="imgoff()">Выкл.</div>
    <div id="exit" onclick="clc()" title="Закрыть">Обычная версия</div>
</div>