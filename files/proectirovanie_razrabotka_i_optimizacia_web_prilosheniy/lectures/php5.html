<title>PHP Строки</title>
<link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="../../css/css.css">
<meta charset="utf-8">
<script src="../../js/jquery-3.3.1.min.js"></script>
<script src="../../js/vision_js.js"></script><script src="../../js/slide_js.js"></script>
<div class="body">
    <p class="vision" title="Версия для слабовидящих" onclick="cl()">
        <svg width="50" height="50" viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
            <path fill="#ffffff"
                d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
            </path>
        </svg>
    </p>
</div>
<div class="header"></div>
<div class="hat"><div class="sandwich" onclick="OpenMenu()">>>></div>
    <p class="name">
        Проектирование, разработка и оптимизация веб-приложений
    </p>
    <div class="links">
        <a href="../../../index.html" class="link">Главная</a>
        <a href="../lectures.html" class="link" title="Лекции">Лекции</a>
        <a href="../video.html" class="link" title="Видео-уроки">Видео-уроки</a>
        <a href="../laboratornie.html" class="link" title="Лабораторные работы">Лабораторные работы</a>
        <a href="../tests.html" class="link" title="Тесты">Тесты</a>
    </div>
</div>
<div class="content">
    <h1>Строки</h1>
    <h2>Управляющие последовательности</h2>
    <p>Если строка заключена в двойные кавычки ("), PHP распознает
        большее количество управляющих последовательностей для
        специальных символов:
    </p>
    <table>
        <caption><strong>Управляющие последовательности</strong></caption>
        <thead>
            <tr>
                <th>Последовательность</th>
                <th>Значение</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><em>\n</em></td>
                <td>новая строка (LF или 0x0A (10) в ASCII)</td>
            </tr>
            <tr>
                <td><em>\r</em></td>
                <td>возврат каретки (CR или 0x0D (13) в ASCII)</td>
            </tr>
            <tr>
                <td><em>\t</em></td>
                <td>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</td>
            </tr>

            <tr>
                <td><em>\v</em></td>
                <td>вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)</td>
            </tr>
            <tr>
                <td><em>\e</em></td>
                <td>escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.4)</td>
            </tr>
            <tr>
                <td><em>\f</em></td>
                <td>подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)</td>
            </tr>
            <tr>
                <td><em>\\</em></td>
                <td>обратная косая черта</td>
            </tr>
            <tr>
                <td><em>\$</em></td>
                <td>знак доллара</td>
            </tr>
            <tr>
                <td><em>\"</em></td>
                <td>двойная кавычка</td>
            </tr>
            <tr>
                <td><em>\[0-7]{1,3}</em></td>
                <td>
                    последовательность символов, соответствующая
                    регулярному выражению символа в восьмеричной
                    системе счисления
                </td>
            </tr>
            <tr>
                <td><em>\x[0-9A-Fa-f]{1,2}</em></td>
                <td>
                    последовательность символов, соответствующая
                    регулярному выражению символа в шестнадцатеричной
                    системе счисления
                </td>
            </tr>
        </tbody>
    </table>

    <h1>Манипулирование строками</h1>
    <p>Для работы со строками в PHP существует целый ряд специализированных
        функций.

    </p>
    <h2>Форматирование строк</h2>
    <p>В PHP есть две функции, позволяющие отформатировать данные перед выводом:
    </p>
    <ul>
        <li><b>printf()</a></b> - выводит отформатированную строку в окно браузера;
        </li>
        <li><b>sprintf()</a></b> - выводит отформатированную строку в переменную.<br>
            Далее можно использовать для записи в файл с помощью функции <b>fputs()</a></b>.
        </li>
    </ul>
    <p>Этим функциям передаются строка управления форматом и сами форматируемые
        данные. Строка управления форматом включает в себя обычные символы, которые
        прямо копируются в результат, и определители преобразования. Каждый
        определитель преобразования начинается с символа процента (<b>%</b>) и
        включает следующие элементы:
    </p>
    <ul>
        <li><b>указатель заполнения</b> используется, если необходимо
            увеличить размер строки. По умолчанию выполняется заполнение пробелами.
            Можно указать и 0. Перед любым другим символом заполнения надо поставить
            одинарную кавычку (<b>'</b>). Необязательный параметр;
        </li>
        <li><b>указатель выравнивания</b>, заданный знаком минус (<b>-</b>),
            определяет выравнивание влево. По умолчанию выполняется выравнивание вправо.
            Необязательный параметр;
        </li>
        <li><b>указатель ширины</b> задает количество символов, которое должно
            содержаться в выводимых данных. Необязательный параметр;
        </li>
        <li><b>указатель точности</b> задает количество десятичных знаков,
            отображаемых для чисел с плавающей запятой. Необязательный параметр;
        </li>
        <li><b>указатель типа</b> задает тип, в соответствии с которым следует
            обрабатывать выводимые данные. Возможные значения:
            <table border="" cellspacing="0" cellpadding="3">
                <colgroup>
                    <col align="center" width="54" style="font-weight:bold">
                </colgroup>
                <tbody>
                    <tr>
                        <td>d</td>
                        <td>десятичное число
                        </td>
                    </tr>
                    <tr>
                        <td>b</td>
                        <td>двоичное число
                        </td>
                    </tr>
                    <tr>
                        <td>c</td>
                        <td>ASCII-эквивалент
                        </td>
                    </tr>
                    <tr>
                        <td>f</td>
                        <td>число с плавающей точкой двойной точности
                        </td>
                    </tr>
                    <tr>
                        <td>o</td>
                        <td>восьмеричное число
                        </td>
                    </tr>
                    <tr>
                        <td>s</td>
                        <td>строка
                        </td>
                    </tr>
                    <tr>
                        <td>x</td>
                        <td>шестнадцатеричное число в нижнем регистре
                        </td>
                    </tr>
                    <tr>
                        <td>X</td>
                        <td>шестнадцатеричное число в верхнем регистре
                        </td>
                    </tr>
                </tbody>
            </table>
        </li>
    </ul>
    <h4>Пример 1</h4>
    <pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Форматирование вывода в окно браузера&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php
$товары = array ("помидоры" =&gt; 15, "огурцы" =&gt; 12, "картофель" =&gt; 10);
echo  "&lt;pre&gt;";
printf ("%-25s%25s\n%'=50s\n", "Наименование", "Цена", "");
foreach ($товары as $наим =&gt; $цена)
	printf ("%'.-25s%'.22.2f\n", $наим, $цена);
echo  "&lt;/pre&gt;";
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

    <h2>Анализ строк</h2>
    <p>PHP содержит множество функций, дающих информацию о строках.
        Наиболее употребимыми являются:
    </p>
    <ul>
        <li><b>strlen()</a></b> - определяет длину строки.
        </li>
        <li><b>strstr()</a></b> - определяет наличие подстроки в строке. Аргументы:
            исходная строка и искомая подстрока. Если такой подстроки в строке нет, функция
            возвращает <tt>false</tt>. Если подстрока в строке есть, функция
            возвращает часть исходной строки, которая начинается с искомой подстроки.
            <pre>echo strstr ("Кто там?", "там"); // выводит "там?"
</pre>
        </li>
        <li><b>stristr()</a></b> - работает так же, как и <tt>strstr()</tt>, но не
            различает регистры.
        </li>
        <li><b>strpos()</a></b> - определяет позицию подстроки в строке. Аргументы:
            исходная строка и искомая подстрока. Если такой подстроки в строке нет, функция
            возвращает <tt>false</tt>. Если подстрока в строке есть, функция
            возвращает номер символа, с которого начинается подстрока.
            <pre>echo strpos ("Кто там?", "там"); // выводит "4"
</pre>
        </li>
        <li><b>substr()</a></b> - возвращает часть строки, ограниченную параметрами.
            Аргументы: исходная строка, начальная позиция, длина подстроки (необязательно).
            Если начальная позиция отрицательна, то отсчет идет от конца строки.
            Если длина не указана, возвращается остаток строки.
            Если длина отрицательна, то подстрока завершается на указанной
            позиции от конца строки.
            <pre>echo substr ("раз-два-три", 4, 3);  // выводит "два"
echo substr ("раз-два-три", 4);     // выводит "два-три"
echo substr ("раз-два-три", -3, 3); // выводит "три"
echo substr ("раз-два-три", 4, -3); // выводит "два-"
</pre>
        </li>
    </ul>

    <h2>Управление строками</h2>
    <p>PHP содержит множество функций управления строками.
        Наиболее употребимыми являются:
    </p>
    <ul>
        <li><b>ltrim()</a></b>, <b>chop()</a></b>, <b>trim()</a></b> - удаляют
            все разделители соответственно в начале строки, в конце строки, в начале и
            конце строки. К разделителям относятся следующие символы:
            <b>"\n"</b> (новая строка), <b>"\r"</b> (возврат каретки),
            <b>"\t"</b> (табуляция), простой пробел.
        </li>
        <li><b>str_replace()</a></b> - заменяет все экземпляры указанной подстроки в
            строке на новую подстроку. Аргументы: заменяемая подстрока, замещающая
            подстрока, исходная строка. Например:
            <pre>echo str_replace ("там", "тут", "Кто там?"); // выводит "Кто тут?"
</pre>
        </li>
        <li><b>substr_replace()</a></b> - заменяет часть строки, ограниченную параметрами.
            Аргументы: исходная строка, замещающая подстрока, начальная позиция, длина
            заменяемой подстроки (необязательно). Если начальная позиция отрицательна, то
            отсчет идет от конца строки. Если длина не указана, используется вся длина
            строки. Если длина отрицательна, то замена завершается на указанной
            позиции от конца строки. Например:
            <pre>echo substr_replace ("раз-два-три", "пять", 4, 3);  // выводит "раз-пять-три"
echo substr_replace ("раз-два-три", "пять", 4);     // выводит "раз-пять"
echo substr_replace ("раз-два-три", "пять", -3, 3); // выводит "раз-два-пять"
echo substr_replace ("раз-два-три", "пять", 4, -3); // выводит "раз-пятьтри"
</pre>
        </li>
        <li><b>strtoupper()</a></b> - переводит символы строки в верхний регистр.
        </li>
        <li><b>strtolower()</a></b> - переводит символы строки в нижний регистр.
        </li>
        <li><b>ucwords()</a></b> - переводит в верхний регистр первый символ каждого слова.
        </li>
        <li><b>explode()</a></b> - разбивает строку на массив.
            Аргументы: строка-разделитель и исходная строка. Например:
            <pre>$строка = "Голова моя машет ушами";
$массив = explode(" ",$str);
// count ($массив) == 4
// $массив[0] == "Голова"
// $массив[1] == "моя"
// $массив[2] == "машет"
// $массив[3] == "ушами"
</pre>
        </li>
        <li><b>implode()</a></b> -объединяет элементы массива со строкой.
            <pre>$array = array('lastname', 'email', 'phone');
$comma_separated = implode(",", $array);
print $comma_separated; // lastname,email,phone
</pre>
            <h1>Функции работы со строками в PHP</h1>
            <ul>
                <li>addcslashes</a> - Экранирует спецсимволы в стиле языка C
                </li>
                <li>addslashes</a> - Экранирует спецсимволы в строке
                </li>
                <li>bin2hex</a> - Преобразует бинарные данные в шестнадцатиричное представление
                </li>
                <li>chr</a> - Возвращает символ по его коду
                </li>
                <li>chunk_split</a> - Разбивает строку на фрагменты
                </li>
                <li>convert_cyr_string</a> - Преобразует строку из одной кириллической кодировки в другую
                </li>
                <li>count_chars</a> - Возвращает информацию о символах, входящих в строку
                </li>
                <li>crc32</a> - Вычисляет CRC32 для строки
                </li>
                <li>crypt</a> - Необратимое шифрование (хэширование)
                </li>
                <li>echo</a> - Выводит одну или более строк
                </li>
                <li>explode</a> - Разбивает строку на подстроки
                </li>
                <li>fprintf</a> - Записывает отформатированную строку в поток
                </li>
                <li>get_html_translation_table</a> - Возвращает таблицу преобразований
                </li>
                <li>hebrev</a> - Преобразует текст на иврите из логической кодировки в визуальную
                </li>
                <li>hebrevc</a> - Преобразует текст на иврите из логической кодировки в визуальную с преобразованием
                    перевод
                </li>
                <li>htmlentities</a> - Преобразует символы в соответствующие HTML сущности
                </li>
                <li>htmlspecialchars</a> - Преобразует специальные символы в HTML сущности
                </li>
                <li>html_entity_decode</a> - Преобразует HTML сущности в соответствующие символы
                </li>
                <li>implode</a> - Объединяет элементы массива в строку(массив в строку)
                </li>
                <li>localeconv</a> - Возвращает информацию о числовых форматах
                </li>
                <li>ltrim</a> - Удаляет пробелы из начала строки
                </li>
                <li>md5</a> - Возвращает MD5 хэш строки
                </li>
                <li>md5_file</a> - Возвращает MD5 хэш файла
                </li>
                <li>metaphone</a> - Возвращает ключ metaphone для строки
                </li>
                <li>nl2br</a> - Вставляет HTML код разрыва строки перед каждым переводом строки
                </li>
                <li>number_format</a> - Форматирует число с разделением групп
                </li>
                <li>ord</a> - Возвращает ASCII код символа
                </li>
                <li>parse_str</a> - Разбирает строку в переменные
                </li>
                <li>print</a> - Выводит строку
                </li>
                <li>printf</a> - Выводит отформатированную строку
                </li>
                <li>quoted_printable_decode</a> - Раскодирует строку, закодированную методом quoted printable
                </li>
                <li>quotemeta</a> - Экранирует специальные символы
                </li>
                <li>rtrim</a> - Удаляет пробелы из конца строки
                </li>
                <li>sha1</a> - Возвращает SHA1 хэш строки
                </li>
                <li>sha1_file</a> - Возвращает SHA1 хэш файла
                </li>
                <li>similar_text</a> - Вычисляет степень похожести двух строк
                </li>
                <li>soundex</a> - Возвращает ключ soundex для строки
                </li>
                <li>sprintf</a> - Возвращает отформатированную строку
                </li>
                <li>sscanf</a> - Разбирает строку в соответствии с заданным форматом
                </li>
                <li>strcasecmp</a> - Сравнение строк без учета регистра, безопасное для данных в двоичной форме
                </li>
                <li>strcmp</a> - Сравнение строк, безопасное для данных в двоичной форме
                </li>
                <li>strcoll</a> - Сравнение строк с учетом текущей локали
                </li>
                <li>strcspn</a> - Возвращает длину участка в начале строки, не соответствующего маске
                </li>
                <li>stripcslashes</a> - Удаляет экранирование символов, произведенное функцией addcslashes()
                </li>
                <li>stripos</a> - Возвращает позицию первого вхождения подстроки без учета регистра
                </li>
                <li>stripslashes</a> - Удаляет экранирование символов, произведенное функцией addslashes()
                </li>
                <li>strip_tags</a> - Удаляет HTML и PHP тэги из строки
                </li>
                <li>stristr</a> - Аналог функции strstr, но независит от регистра
                </li>
                <li>strlen</a> - Возвращает длину строки
                </li>
                <li>strnatcasecmp</a> - Сравнение строк без учета регистра с использованием алгоритма
                </li>
                <li>strnatcmp</a> - Сравнение строк с использованием алгоритма "естественного упорядочения"
                </li>
                <li>strncasecmp</a> - Сравнение первых n символов строк без учета регистра, безопасное для данных в
                    двоичной форме
                </li>
                <li>strncmp</a> - Сравнение первых n символов строк без учета регистра, безопасное для данных в двоичной
                    форме
                </li>
                <li>strpos</a> - Находит первое вхождение подстроки в строку
                </li>
                <li>strrchr</a> - Находит последнее вхождение символа в строку
                </li>
                <li>strrev</a> - Переворачивает строку
                </li>
                <li>strripos</a> - Возвращает позицию последнего вхождения подстроки без учета регистра
                </li>
                <li>strrpos</a> - Находит последнее вхождение символа в строку
                </li>
                <li>strspn</a> - Возвращает длину участка в начале строки, соответствующего маске
                </li>
                <li>strstr</a> - Находит первое вхождение подстроки
                </li>
                <li>strtok</a> - Разбивает строку
                </li>
                <li>strtolower</a> - Преобразует строку в нижний регистр
                </li>
                <li>strtoupper</a> - Преобразует строку в верхний регистр
                </li>
                <li>strtr</a> - Преобразует заданные символы
                </li>
                <li>str_ireplace</a> - Регистро-независимый вариант функции str_replace().
                </li>
                <li>str_pad</a> - Дополняет строку другой строкой до заданной длины
                </li>
                <li>str_repeat</a> - Возвращает повторяющуюся строку
                </li>
                <li>str_replace</a> - Заменяет строку поиска на строку замены
                </li>
                <li>str_rot13</a> - Выполняет над строкой преобразование ROT13
                </li>
                <li>str_shuffle</a> - Переставляет символы в строке
                </li>
                <li>str_split</a> - Преобразует строку в массив
                </li>
                <li>str_word_count</a> - Возвращает информацию о словах, входящих в строку
                </li>
                <li>substr</a> - Функция возвращает часть строки
                </li>
                <li>substr_count</a> - Подсчитывает число вхождений подстроки в строку
                </li>
                <li>substr_replace</a> - Заменяет часть строки
                </li>
                <li>trim</a> - Удаляет пробелы из начала и конца строки
                </li>
                <li>ucfirst</a> - Преобразует первый символ строки в верхний регистр
                </li>
                <li>ucwords</a> - Преобразует в верхний регистр первый символ каждого слова в строке
                </li>
                <li>vprintf</a> - Выводит отформатированную строку
                </li>
                <li>vsprintf</a> - Возвращает отформатированную строку
                </li>
                <li>wordwrap</a> - Выполняет перенос строки на данное количество символов с использованием символа
                    разрыва строки
                </li>
            </ul>

            <h1> Особенности операторов сравнения применительно к строкам.</h1>
            <pre>$one = 1;   // Число один.
$zero = 0;  // Присваиваем число нуль.
if ($one == "") echo 1;    // Очевидно, не равно - не выводит 1.
if ($zero == "") echo 2;   //* Внимание! Вопреки ожиданиям печатает 2!
if ("" == $zero) echo 3;   //* И это тоже не поможет - печатает!..
if ("$zero" == "") echo 4; // Так правильно.
if (strval($zero) == "") echo 5; // Так тоже правильно - не выводит 5.
if ($zero === "") echo 6;  // Лучший способ, но не действует в PHP 3.
</pre>

            <h4>chop()</h4>
            <p>Функция chop( ) возвращает строку после удаления из нее завершающих пропусков и символов новой строки.
                Синтаксис функции chop( ):
            </p>
            <p>string chop(string строка)
            </p>
            <p>В следующем примере функция chop( ) удаляет лишние символы новой строки:
            </p>
            <pre>$header = "Table of Contents\n\n";
$header = chop($header);
// $header = "Table of Contents"
</pre>


            <h4>str_pad()</h4>
            <p>Функция str_pad( ) выравнивает строку до определенной длины заданными символами и возвращает
                отформатированную строку. Синтаксис функции str_pad( ):
            </p>
            <p>string str_pad (string строка, int длина_дополнения [, string дополнение [, int тип_дополнения]])
            </p>
            <p>Если необязательный параметр дополнение не указан, строка дополняется пробелами. В противном случае
                строка дополняется заданными символами.
                По умолчанию строка дополняется справа; тем не менее, вы можете передать в параметре тип_дополнения
                константу STR_PAD_RIGHT, STR_PAD_LEFT или STR_PAD_BOTH,
                что приведет к дополнению строки в заданном направлении. Пример демонстрирует дополнение строки функцией
                str_pad( ) с параметрами по умолчанию:
            </p>
            <pre>$food = "salad";
print str_pad ($food, 5): // Выводит строку "salad
</pre>
            В следующем примере используются необязательные параметры функции str_pad( ):
            <pre>$header = "Table of Contents";
print str_pad ($header, 5, "=+=+=", STR_PAD_BOTH);
// В браузере выводится строка =+=+= Таbе of Contents=+=+="
</pre>

            <h4>trim()</h4>
            <p>Функция trim( ) удаляет псе пропуски с обоих краев строки и возвращает полученную строку. Синтаксис
                функции trim( ):
            </p>
            <p>string trim (string страна]
            </p>
            <p>К числу удаляемых пропусков относятся и специальные символы \n, \r, \t, \v и \0.

            </p>
            <h4>ltrim()</h4>
            <p>Функция lrim( ) удаляет все пропуски и специальные символы с левого края строки и возвращает полученную
                строку. Синтаксис функции ltrim( ):
            </p>
            <p>string ltrim (string строка)
            </p>
            <p>Функция удаляет те же специальные символы, что и функция trim( ).

            </p>
            <h4>strlen()</h4>
            Определение длины строки
            <p>Длину строки в символах можно определить при помощи функции strlen( ). Синтаксис .функции strlen( ):
            </p>
            <p>int strlen (string строка)
            </p>
            <p>Следующий пример демонстрирует определение длины строки функцией strlen( ):
            </p>
            <pre>$string = "hello";
$length = strlen($string);
// $length = 5
</pre>

            <h2>Сравнение двух строк</h2>

            <p>Сравнение двух строк принадлежит к числу важнейших строковых операций любого языка.
                Хотя эту задачу можно решить несколькими разными способами, в РНР существуют четыре функции сравнения
                строк:
            </p>
            <ul>
                <li>strcmp()</a></li>
                <li>strcasecmp()</a></li>
                <li>strspn()</a></li>
                <li>strcspn()</a></li>
            </ul>

            <h4>strcmp()</h4>
            <p>Функция strcmp( ) сравнивает две строки с учетом регистра символов. Синтаксис функции strcmp( ):
                int strcmp (string строка1, string строка2)
            </p>
            <p>После завершения сравнения strcmp( ) возвращает одно из трех возможных значений:
            </p>
            <ul>
                <li>0, если строка1 и строка2 совпадают;</li>
                <li>&lt; 0, если строка1 меньше, чем строка2;</li>
                <li>&gt; 0, если строка2 меньше, чем строка1.</li>
            </ul>
            <p>В следующем фрагменте сравниваются две одинаковые строки:
            </p>
            <pre>$sthng1 = "butter";
$string2 = "butter";
if ((strcmp($string1. $string2)) == 0) :
print "Strings are equivalent!"; endif;
// Команда if возвращает TRUE
</pre>

            <h4>strcasecmp()</h4>
            <p>Функция strcasecmp( ) работает точно так же, как strcmp( ), за одним исключением - регистр символов при
                сравнении не учитывается.
                Синтаксис функции strcasecmp( ):
            </p>
            <p>int strcasecmp (string cтpoкa1, string строка2)
            </p>
            <p>В следующем фрагменте сравниваются две одинаковые строки:
            </p>
            <pre>$string1 = "butter";
$string2 = "Butter";
if ((strcmp($string1, $string2)) == 0) :
print "Strings are equivalent!";
endif;
// Команда if возвращает TRUE
</pre>

            <h4>strspn()</h4>
            <p>Функция strspn( ) возвращает длину первого сегмента строки1, содержащего символы, присутствующие в
                строке2. Синтаксис функции strspn( ):
            </p>
            <p>int strspn (string строка1, string строка2)
            </p>
            <p>Следующий фрагмент показывает, как функция strspn( ) используется для проверки пароля:
            </p>
            <pre>$password = "12345";
if (strspn($password, "1234567890") != strlen($password)) :
print "Password cannot consist solely of numbers!";
endif:
</pre>

            <h4>strcspn()</h4>
            <p>Функция strcspn( ) возвращает длину первого сегмента строки1, содержащего символы, отсутствующие в
                строке2. Синтаксис функции strcspn( ):
            </p>
            <p>int strcspn (string строка1, string строка2)
            </p>
            <p>В следующем фрагменте функция strcspn( ) используется для проверки пароля:
            </p>
            <pre>$password = "12345";
if (strcspn($password, "1234567890") == 0) :
print "Password cannot consist solely of numbers!";
endif;
</pre>

            <h2>Обработка строковых данных без применения регулярных выражений</h2>
            <p>При обработке больших объемов информации функции регулярных выражений сильно замедляют выполнение
                программы.
                Эти функции следует применять лишь при обработке относительно сложных строк, в которых регулярные
                выражения действительно необходимы.
                Если же анализ текста выполняется по относительно простым правилам, можно воспользоваться стандартными
                функциями РНР,
                которые заметно ускоряют обработку. Все эти функции описаны ниже.

            </p>
            <h4>strtok()</h4>
            <p>Функция strtok( ) разбивает строку на лексемы по разделителям, заданным вторым параметром.
                Синтаксис функции strtok( ):
            </p>
            <p>string strtok (string строка, string разделители)
            </p>
            <p>У функции strtok( ) есть одна странность: чтобы полностью разделить строку,
                функцию необходимо последовательно вызвать несколько раз.
                При очередном вызове функция выделяет из строки следующую лексему.
                При этом параметр строка задается всего один раз - функция отслеживает текущую позицию в строке до тех
                пор,
                пока строка не будет полностью разобрана на лексемы или не будет задан новый параметр строка.
                Следующий пример демонстрирует разбиение строки по нескольким разделителям:
            </p>
            <pre>$info = "WJ Gi1more:wjgilmore@hotmail.com | Columbus, Ohio";
// Ограничители - двоеточие (:), вертикальная черта (|) и запятая (.)
$tokens = ":|,";
$tokenized = strtok($info, $tokens);
// Вывести элементы массива $tokenized
while ($tokenized) :
echo "Element = $tokenized&lt;br&gt;";
// Обратите внимание: при последующих вызовах strtok
// первый аргумент не передается
$tokenized = strtok($tokens);
endwhile;
</pre>
            <h4>parse_str()</h4>
            <p>Функция parse_str( ) выделяет в строке пары &lt;переменная-значение&gt; и присваивает значения
                переменных в текущей области видимости. Синтаксис функции parse_str( ):
            </p>
            <p>void parse_str (string строка)
            </p>
            <p>Функция parse_str( ) особенно удобна при обработке URL, содержащих данные форм HTML или другую
                расширенную информацию.
                В следующем примере анализируется информация, переданная через URL.
                Строка представляет собой стандартный способ передачи данных между страницами либо откомпилированных
                в гиперссылке, либо введенных в форму HTML:
            </p>
            <pre>$url = "fname=wj&amp;lname=gilmore&amp;zip=43210";
parse_str($url);
// После выполнения parse_str( ) доступны следующие переменные:
// $fname = "wj":
// $lname = "gilmore";
// $zip = "43210"
</pre>
            <p>Поскольку эта функция создавалась для работы с URL, она игнорирует символ амперсанд (&amp;).

            </p>
            <h4>explode()</h4>
            <p>Функция explode() делит строку на элементы и возвращает эти элементы в виде массива. Синтаксис функции
                explode():
            </p>
            <p>array explode (string разделитель, string строка [, int порог])
            </p>
            <p>Разбиение происходит по каждому экземпляру разделителя, причем количество полученных
                фрагментов может ограничиваться необязательным параметром порог.
            </p>
            <p>Разделение строки функцией explode( ) продемонстрировано в следующем примере:
            </p>
            <pre>$info = "wilson | baseball | indians";
$user = explode("|", $info);
// $user[0] = "wilson";
// $user[1] = "baseball";
// $user[2] = "Indians";
</pre>
            <p>Функция explode( ) практически идентична функции регулярных выражений POSIX split( ), описанной выше.
                Главное различие заключается в том, что передача регулярных выражений в параметрах допускается только
                при вызове split( ).

            </p>
            <h4>implode()</h4>
            <p>Если функция explode( ) разделяет строку на элементы массива, то ее двойник - функция implode( ) -
                объединяет массив в строку. Синтаксис функции implode( ):
            </p>
            <p>string implode (string разделитель, array фрагменты)
            </p>
            <p>Формирование строки из массива продемонстрировано в следующем примере:
            </p>
            <pre>$ohio_cities = array ("Columbus", "Youngstown", "Cleveland", "Cincinnati");
$city_string = implode("l", $ohio_cities);
// $city_string = "Columbus | Youngstown | Cleveland | Cincinnati";
</pre>
            <p>У implode( ) имеется псевдоним - функция join( ).

            </p>
            <h4>strpos()</h4>
            <p>Функция strpos( ) находит в строке первый экземпляр заданной подстроки. Синтаксис функции strpos():
            </p>
            <p>int strpos (string строка, string подстрока [, int смещение])
            </p>
            <p>Необязательный параметр offset задает позицию, с которой должен начинаться поиск. Если подстрока не
                найдена, strpos() возвращает FALSE (0).
            </p>
            <p>В следующем примере определяется позиция первого вхождения даты в файл журнала:
            </p>
            <pre>$log = "
206.169.23.11:/www/:2000-08-10
206.169.23.11:/www/logs/:2000-02-04
206.169.23.11:/www/img/:1999-01-31";
// В какой позиции в журнале впервые встречается 1999 год?
$pos = strpos($log, "1999");
// $pos = 95. поскольку первый экземпляр "1999"
// находится в позиции 95 строки, содержащейся в переменной $log
</pre>

            <h4>strrpos()</h4>
            <p>Функция strrpos( ) находит в строке последний экземпляр заданного символа. Синтаксис функции strrpos( ):
            </p>
            <p>int strpos (string строка, char символ)
            </p>
            <p>По возможностям эта функция уступает своему двойнику - функции strpos( ), поскольку она позволяет искать
                только отдельный символ,
                а не всю строку. Если во втором параметре strrpos( ) передается строка, при поиске будет использован
                только ее первый символ.

            </p>
            <h4>str_replace()</h4>
            <p>Функция str_replace( ) ищет в строке все вхождения заданной подстроки и заменяет их новой подстрокой.
                Синтаксис функции str_replace( ):
            </p>
            <p>string str_replace (string подстрока, string замена, string строка)
            </p>
            <p>Функция substr_replace( ), описанная ниже в этом разделе, позволяет провести заме ну лишь в определенной
                части строки.
                Ниже показано, как функция str_replace( ) используется для проведения глобальной замены в строке.
            </p>
            <p>Если подстрока ни разу не встречается в строке, исходная строка не изменяется:
            </p>
            <pre>$favorite_food = "My favorite foods are ice cream and chicken wings";
$favorite_food = str_replace("chicken_wings", "pizza", $favohte_food);
// $favorite_food = "My favorite foods are ice cream and pizza"
</pre>

            <h4>strstr()</h4>
            <p>Функция strstr( ) возвращает часть строки, начинающуюся с первого вхождения заданной подстроки. Синтаксис
                функции strstr( ):
            </p>
            <p>string strstr (string строка, string подстрока)
            </p>
            <p>В следующем примере функция strstr( ) используется для выделения имени домена из URL:
            </p>
            <pre>$url = "http://www.apress.com"; $domain - strstr($url, ".");
// $domain = ".apress.com"
</pre>

            <h4>substr()</h4>
            <p>Функция substr( ) возвращает часть строки, начинающуюся с заданной начальной
                позиции и имеющую заданную длину. Синтаксис функции substr( ):
            </p>
            <p>string substr (string строка, int начало [, int длина])
            </p>
            <p>Если необязательный параметр длина не указан, считается, что подстрока начинается
                с заданной начальной позиции и продолжается до конца строки. При использовании этой
                функции необходимо учитывать четыре обстоятельства:
            </p>
            <ul>
                <li>если параметр начало положителен, возвращаемая подстрока начинается с позиции строки с заданным
                    номером;
                </li>
                <li>если параметр начало отрицателен, возвращаемая подстрока начинается с позиции (длина строки -
                    начало);
                </li>
                <li>если параметр длина положителен, в возвращаемую подстроку включаются все символы от позиции начало
                    до позиции начало+длина. Если последняя величина превышает длину строки, возвращаются символы до
                    конца строки;
                </li>
                <li>если параметр длина отрицателен, возвращаемая подстрока заканчивается на заданном расстоянии от
                    конца строки.
                </li>
            </ul>
            <p>Помните о том, что параметр начало определяет смещение от первого символа строки;
                таким образом, возвращаемая строка в действительности начинается с символа с номером (начало + 1).
            </p>
            <p>Следующий пример демонстрирует выделение части строки функцией substr( ):
            </p>
            <pre>$car = "1944 Ford"; Smodel = substr($car, 6);
// Smodel = "Ford"
</pre>
            <p>Пример с положительным параметром длина:
            </p>
            <pre>$car = "1944 Ford";
$model = substr($car, 0, 4);
// $model = "1944"
</pre>
            Пример с отрицательным параметром длина:
            <pre>$car = "1944 Ford";
$model = substr($car, 2, -5);
// $model = "44"
</pre>

            <h4>substr_count()</h4>
            Функция substr_count( ) возвращает количество вхождений подстроки в заданную строку. Синтаксис функции
            substr_count( ):
            int substr_count (string строка, string подстрока)
            В следующем примере функция substr_count( ) подсчитывает количество вхождений подстроки ain:
            <pre>$tng_twist = "The rain falls mainly on the plains of Spain";
$count = substr_count($tng_twist, "ain");
// $count = 4
</pre>

            <h4>substr_replace()</h4>
            <p>Функция substr_replace( ) заменяет часть строки, которая начинается с заданной позиции. Если задан
                необязательный параметр длина,
                заменяется фрагмент заданной длины; в противном случае производится замена по всей длине заменяющей
                строки.
                Синтаксис функции substr_replace( ):
            </p>
            <p>string substr_replace (string строка, string замена, int начало [, int длина])
            </p>
            <p>Параметры начало и длина задаются по определенным правилам:
            </p>
            <ul>
                <li>если параметр начало положителен, замена начинается с заданной позиции;
                </li>
                <li>если параметр начало отрицателен, замена начинается с позиции (длина строки -начало);
                </li>
                <li>если параметр длина положителен, заменяется фрагмент заданной длины;
                </li>
                <li>если параметр длина отрицателен, замена завершается в позиции (длина строки -длина).
                </li>
            </ul>
            <p>Простая замена текста функцией substr_replace( ) продемонстрирована в следующем примере:
            </p>
            <pre>$favs = " 's favorite links";
$name = "Alessia";
// Параметры "0, 0" означают, что заменяемый фрагмент начинается
// и завершается в первой позиции строки.
$favs - substr_replace($favs, $name, 0, 0);
print $favs:
</pre>

            <h2>Преобразование строк и файлов к формату HTML и наоборот</h2>
            <p>Преобразовать строку или целый файл к формату, подходящему для просмотра в web-браузере (или наоборот),
                проще, чем может показаться на первый взгляд. В РНР для этого существуют специальные функции.

            </p>
            <h3>Преобразование текста в HTML</h3>
            <p>Быстрое преобразование простого текста к формату web-браузера - весьма распространенная задача.
                В ее решении вам помогут функции, описанные в этом разделе.
            </p>
            <h4>nl2br()</h4>
            <p>Функция nl2br() заменяет все символы новой строки (\n) эквивалентными конструкциями HTML.
            </p>
            <p>Синтаксис функции nl2br():
            </p>
            <p>string nl2br (string строка)
            </p>
            <p>Символы новой строки могут быть как видимыми (то есть явно включенными в строку), так и невидимыми
                (например, введенными в редакторе).
                В следующем примере текстовая строка преобразуется в формат HTML посредством замены символов \n
                разрывами строк:
            </p>
            <pre>// Текстовая строка, отображаемая в редакторе.
$text_recipe = "
Party Sauce recipe:
1 can stewed tomatoes
3 tablespoons fresh lemon juice
Stir together, server cold.";
// Преобразовать символы новой строки в <br>
$htinl_recipe = nl2br($text_recipe)
</pre>
            При последующем выводе $html_recipe браузеру будет передан следующий текст в формате HTML:
            <pre>Party Sauce recipe:&lt;br&gt;
1 can stewed tomatoes&lt;br&gt;
3 tablespoons fresh lemon juice&lt;br&gt;
Stir together, server cold.&lt;br&gt;
</pre>

            <h4>htmlentities()</h4>
            <p>Функция htmlentities( ) преобразует символы в эквивалентные конструкции HTML. Синтаксис функции
                htmlentities:
            </p>
            <p>string htmlentities (string строка)
            </p>
            <p>В следующем примере производится необходимая замена символов строки для вывода в браузере:
            </p>
            <pre>$user_input = "The cookbook, entitled Cafe Francaise' costs &lt; $42.25.";
$converted_input = htmlentities($user_input);
// $converted_input = "The cookbook, entitled 'Cafè
// Fracçiaise' costs &lt; 42.25.";
</pre>
            <p>Функция htmlentities( ) в настоящее время работает только для символов кодировки ISO-8559-1
                (ISO-Latin-1).
                Кроме того, она не преобразует пробелы в &nbsp;, как следовало бы ожидать.

            </p>
            <h4>htmlspecialchars()</h4>
            <p>Функция htmlspecialchars( ) заменяет некоторые символы, имеющие особый смысл в контексте HTML,
                эквивалентными конструкциями HTML.
                Синтаксис функции htmlspecialchars( ):
            </p>
            <p>string htmlspecialchars (string строка)
            </p>
            <p>Функция html special chars( ) в настоящее время преобразует следующие символы:
                &amp; преобразуется в &amp;; " " преобразуется в ";
                &lt; преобразуется в &lt;; &gt; преобразуется в &gt;.
            </p>
            <p>В частности, эта функция позволяет предотвратить ввод пользователями разметки HTML в интерактивных
                web-приложениях
                (например, в электронных форумах). Ошибки, допущенные в разметке HTML, могут привести к тому, что вся
                страница
                будет формироваться неправильно. Впрочем, у этой задачи существует и более эффективное решение
                - полностью удалить теги из строки функцией strip_tags( ).
            </p>
            <p>Следующий пример демонстрирует удаление потенциально опасных символов функцией htmlspeclalchars( ):
            </p>
            <pre>$user_input = "I just can't get &lt;enough&gt; of PHP &amp; those fabulous cooking recipes!";
$conv_input = htmlspecialchars($user_input);
// $conv_input = "I just can't &lt;&lt;enough&gt;&gt; of PHP &amp; those fabulous cooking
recipes!"
</pre>
            <p>Если функция htmlspecialchars( ) используется в сочетании с nl2br( ), то последнюю следует вызывать после
                htmlspecialchars( ).
                В противном случае конструкции &lt;br&gt;, сгенерированные при вызове nl2br( ), преобразуются в видимые
                символы.

            </p>
            <h4>get_html_translation_table()</h4>
            <p>Функция get_html_translation_table( ) обеспечивает удобные средства преобразования текста в эквиваленты
                HTML Синтаксис функции get_htrril_translation_table( ):
            </p>
            <p>string get_html_translation_table (int таблица)
            </p>
            <p>Функция get_html_translation_table( ) возвращает одну из двух таблиц преобразования (определяется
                параметром таблица),
                используемых в работе стандартных функций htmlspecialchars( ) и htmlentities( ).
                Возвращаемое значение может использоваться в сочетании с другой стандартной функцией, strtr(), для
                преобразования текста в код HTML.
            </p>
            <p>Параметр таблица принимает одно из двух значений:
            </p>
            <ul>
                <li>HTML_ENTITIES;
                </li>
                <li>HTML_SPECIALCHARS.
                </li>
            </ul>
            <p>В следующем примере функция get_html_translation_table( ) используется при преобразовании текста в код
                HTML:
            </p>
            <pre>$string = "La pasta e il piatto piu amato in Italia";
$translate = get_html_translation_table(HTML_ENTITIES);
print strtr($string, $translate);
// Специальные символы преобразуются в конструкции HTML
// и правильно отображаются в браузере.
</pre>
            <p>Кстати, функция array_flip( ) позволяет провести преобразование текста в HTML в обратном направлении и
                восстановить исходный текст. Предположим, что вместо вывода результата strtr( ) в предыдущем примере мы
                присвоили его переменной $translated string.
            </p>
            <p>В следующем примере исходный текст восстанавливается функцией array_flip( ):
            </p>
            <pre>$translate = array_flip($translate);
$translated_string - "La pasta é il piatto piú amato in Italia";
$original_string = strtr($translated_string, $translate);
// $original_string = "La pasta e il piatto piu amato in Italia";
</pre>

            <h4>strtr()</h4>
            <p>Функция strtr( ) транслирует строку, то есть заменяет в ней все символы, входящие в строку источник,
                соответствующими символами строки приемник. Синтаксис функции strtr( ):
            </p>
            <p>string strtr (string строка, string источник, string приемник)
            </p>
            <p>Если строки источник и приемник имеют разную длину, длинная строка усекается до размеров короткой строки.
            </p>
            <p>Существует альтернативный синтаксис вызова strtr( ) с двумя параметрами; в этом случае второй параметр
                содержит ассоциативный массив, ключи которого соответствуют заменяемым подстрокам, а значения -
                заменяющим подстрокам. В следующем примере теги HTML заменяются XML-подобными конструкциями:
            </p>
            <pre class="adb"><code class="language-php">&lt;?
<span class="variable">$source</span> = <span class="keyword">array</span>(<span class="string">"&lt;title&gt;"</span> =&gt; <span class="string">"&lt;h1&gt;"</span>, <span class="string">"&lt;/title&gt;"</span> =&gt; <span class="string">"&lt;/h1&gt;"</span>);
<span class="variable">$string</span> = <span class="string">"&lt;h1&gt;Today In PHP-Powered News&lt;/h1&gt;"</span>;
<span class="keyword">print</span> strtr(<span class="variable">$string</span>, <span class="variable">$source</span>);
<span class="comment">// Выводится строка "&lt;title&gt;Today in PHP-Powered News&lt;/title&gt;"</span>
<span class="preprocessor">?&gt;</span></code></pre>

            <h3>Преобразование HTML в простой текст</h3>
            <p>Иногда возникает необходимость преобразовать файл в формате HTML в простой текст. Функции, описанные
                ниже, помогут вам в решении этой задачи.

            </p>
            <h4>strip_tags()</h4>
            <p>Функция strip_tags( ) удаляет из строки все теги HTML и РНР, оставляя в ней только текст. Синтаксис
                функции strip_tags( ):
            </p>
            <p>string strip_tags (string строка [, string разрешенные_тerи])
            </p>
            <p>Необязательный параметр разрешенные_теги позволяет указать теги, которые должны пропускаться в процессе
                удаления.
            </p>
            <p>Ниже приведен пример удаления из строки всех тегов HTML функцией strip_tags( ):
            </p>
            <pre>$user_input = "I just <b>love</b> РНР and <i>gourment</i> recipes!";
$stripped_input = strip_tags($user_input);
// $stripped_input = "I just love PHP and gourmet recipes!";
</pre>
            <p>В следующем примере удаляются не все, а лишь некоторые теги:
            </p>
            <pre
                class="adb"><code class="language-html php"><span class="variable">$input</span> = <span class="string">"I &amp;lt;b&gt;love&amp;lt;/b&gt; to &amp;lt;a href = \"http://www.eating.com\"&gt;eat!&amp;lt;/a&gt;!"</span>;
<span class="variable">$strip_input</span> = strip_tags (<span class="variable">$user_input</span>, <span class="string">"&amp;lt;a&gt;"</span>);
<span class="comment">// $strip_input = "I love to &amp;lt;a href = \"http://www.eating.com\"&gt;eat!&amp;lt;/a&gt;!";</span></code></pre>
            <p>Удаление тегов из текста также производится функцией fgetss().

            </p>
            <h4>get_meta_tags()</h4>
            <p>Хотя функция get_meta_tags( ) и не имеет прямого отношения к преобразованию текста, зто весьма полезная
                функция, о которой следует упомянуть.
                Синтаксис функции get_meta_tags( ):
            </p>
            <p>array get_meta_tags (string имя_файла/URL [, int включение_пути])
            </p>
            <p>Функция get_meta_tags( ) предназначена для поиска в файле HTML тегов МЕТА.
            </p>
            <p>Теги МЕТА содержат информацию о странице, используемую главным образом поисковыми системами.
                Эти теги находятся внутри пары тегов .... Применение тегов МЕТА продемонстрировано
                в следующем фрагменте (назовем его example.html, поскольку он будет использоваться в листинге 8.2):
                [/html]

                <title>PHP Recipes</title>
                <meta name="keywords" content="PHP, code, recipes, web">
                <meta name="description" content="Информация о PHP">
                <meta name="author" content="KDG">

                [/html]

                Функция get_meta_tags( ) ищет в заголовке документа теги, начинающиеся словом МЕТА,
                и сохраняет имена тегов и их содержимое в ассоциативном массиве.
                В листинге 8.2 продемонстрировано применение этой функции к файлу example.html.

                Листинг 8.2. Извлечение тегов МЕТА из файла HTML функцией get_meta_tags( )

            </p>
            <pre>$meta_tags = get_meta_tags("example.html"):
// Переменная $meta_tags содержит массив со следующей информацией:
// $meta_tags["keywords"] = "PHP, code, recipes, web"
// $meta_tags["description"] = "Информация о PHP"
// $meta_tags["author"] = "KDG";
</pre>
            <p>Интересная подробность: данные тегов МЕТА можно извлекать не только из файлов, находящихся на сервере, но
                и из других URL.

            </p>
            <h3>Преобразование строки к верхнему и нижнему регистру</h3>
            <p>В РНР существует четыре функции, предназначенных для изменения регистра строки:
            </p>
            <ul>
                <li>strtolower()</a>;
                </li>
                <li>strtoupper()</a>;
                </li>
                <li>ucfirst()</a>;
                </li>
                <li>ucwords()</a>.
                </li>
            </ul>
            <h4>strtolower( )</h4>
            <p>Функция strtolower( ) преобразует все алфавитные символы строки к нижнему регистру. Синтаксис функции
                strtolower():
            </p>
            <p>string strtolower(string строка)
            </p>
            <p>Неалфавитные символы функцией не изменяются. Преобразование строки к нижнему регистру функцией
                strtolower() продемонстрировано в следующем примере:
            </p>
            <pre>$sentence = "COOKING and PROGRAMMING PHP are my TWO favorite!";
$sentence = strtolower($sentence);
// После вызова функции $sentence содержит строку
// "cooking and programming php are my two favorite!"
</pre>

            <h4>strtoupper()</h4>
            <p>Строки можно преобразовывать не только к нижнему, но и к верхнему регистру. Преобразование выполняется
                функцией strtoupper(), имеющей следующий синтаксис:
            </p>
            <p>string strtoupper (string строка)
            </p>
            <p>Неалфавитные символы функцией не изменяются. Преобразование строки к верхнему регистру функцией
                strtoupper() продемонстрировано в следующем примере:
            </p>
            <pre>$sentence = "cooking and programming PHP are my two favorite!";
$sentence = strtoupper($sentence);
// После вызова функции $sentence содержит строку
// "COOKING AND PROGRAMMING PHP ARE MY TWO FAVORITE!"
</pre>

            <h4>ucfirst()</h4>
            <p>Функция ucfirst( ) преобразует к верхнему регистру первый символ строки - при условии, что он является
                алфавитным символом. Синтаксис функции ucfirst():
            </p>
            <p>string ucfirst (string строка)
            </p>
            <p>Неалфавитные символы функцией не изменяются. Преобразование первого символа строки функцией ucfirst()
                продемонстрировано в следующем примере:
            </p>
            <pre>&amp;sentence = "cooking and programming PHP are my two favorite!";
$sentence = ucfirst($sentence);
// После вызова функции $sentence содержит строку
// "Cooking and programming PHP are mу two favorite!"
</pre>

            <h4>ucwords()</h4>
            <p>Функция ucwords( ) преобразует к верхнему регистру первую букву каждого слова в строке. Синтаксис функции
                ucwords():
            </p>
            <p>string ucwords (string строка")
            </p>
            <p>Неалфавитные символы функцией не изменяются. "Слово" определяется как последовательность символов,
                отделенная от других элементов строки пробелами. В следующем примере продемонстрировано преобразование
                первых символов слов функцией ucwords( ):
            </p>
            <pre>$sentence = "cooking and programming PHP are my two favorite!";
$sentence = ucwords($sentence);
// После вызова функции $sentence содержит строку
// "Cooking And Programming PHP Are My Two Favorite!"
</pre>

            <h4>strrchr()</h4>
            <p>strrchr("строка", "о") - Находит последнее вхождение подстроки
            </p>
            <p>Если подстрока не найдена, возвращает FALSE.
            </p>
            <p>В отличие от strchr(), если искомая строка состоит более чем из одного символа, используется только
                первый символ.
            </p>
            <p>Если второй параметр не является строкой, он приводится к целому и трактуется как код символа.
            </p>
            <pre>// получить последнюю директорию из $PATH
$dir = substr(strrchr($PATH, ":"), 1);
// получить все после последнего перевода строки
$text = "Line 1\nLine 2\nLine 3";
$last = substr(strrchr($text, 10), 1 );
</pre>


            <h4>highlight_string()</h4>
            highlight_string- выделение синтаксиса строки.
            <p>mixed highlight_string (string str [, bool return])
            </p>
            <p>Функция highlight_string() выводит версию с расцвеченным синтаксисом строки str, используя цвета,
                определённые во встроенном выделении синтаксиса PHP.
            </p>
            <p>Если второй параметр return имеет значение TRUE, то highlight_string() возвратит версию раскрашенного
                кода как строку, вместо её печати. Если второй параметр не имеет значение TRUE, highlight_string()
                возвратит TRUE при успехе, FALSE при неудаче.
            </p>
            <p>Примечание: 1.параметр return стал доступен, начиная с PHP 4.2.0. До этого он работал, как по умолчанию,
                т.е. FALSE.<br>
                2.Функция Highlight_String() различает PHP код по тегам &lt;?php ?&gt;.
                <b>show_source()</b> - синоним <b>highlight_file()</b>.
                Для изменения цвета выделения по умолчанию используйте следующие PHP директивы:
            </p>
            <pre>highlight.bg #FFFFFF
highlight.comment #FF8000
highlight.default #0000BB
highlight.html #000000
highlight.keyword #007700
highlight.string #DD0000
</pre>
            в .htaccess:
            <pre>php_flag highlight.bg #FFFFFF
 </pre>
            в PHP:
            <pre>if(@ini_get('highlight.bg')=='') ...
</pre>



            <h4>addslashes()</h4> - Экранирует спецсимволы в строке
            <p>Возвращает сроку, в которой перед каждым спецсимволом добавлен обратный слэш (\),
                например для последующего использования этой строки в запросе к базе данных.
            </p>
            <p>Экранируются одиночная кавычка ('), дойная кавычка ("), обратный слэш (\) и NUL (байт NULL).
            </p>
            <pre>$str = "Is your name O'reilly?";
// выводит: Is your name O\'reilly?
echo addslashes($str);
</pre>

            <h4>stripslashes</h4> - Удаляет экранирование символов, произведенное функцией addslashes()
            Удаляет экранирующие бэкслэши. (\' преобразуется в ', и т.д.). Двойные бэкслэши (\\) преобразуется в
            одиночные(\).

            <h4>wordwrap()</h4> Выполняет перенос строки на данное количество символов с использованием символа разрыва
            строки
            <pre class="adb"><code class="language-html php"><span class="comment">// Использование wordwrap().</span>
<span class="function"><span class="keyword">function</span> <span class="title">cite</span><span class="params">(<span class="variable">$ourText</span>, <span class="variable">$maxlen</span>=<span class="number">60</span>, <span class="variable">$prefix</span>=<span class="string">"&gt; "</span>)</span> {</span>
   <span class="variable">$st</span> = wordwrap(<span class="variable">$ourText</span>, <span class="variable">$maxlen</span>-strlen(<span class="variable">$prefix</span>), <span class="string">"\n"</span>);
   <span class="variable">$st</span> = <span class="variable">$prefix</span>.str_replace(<span class="string">"\n"</span>, <span class="string">"\n$prefix"</span>, <span class="variable">$st</span>);
   <span class="keyword">return</span> <span class="variable">$st</span>;
}
<span class="keyword">echo</span> cite(<span class="string">"The first Matrix I designed was quite naturally
perfect, it was a work of art - flawless, sublime. A triumph
equalled only by its monumental failure. The inevitability
of its doom is apparent to me now as a consequence of the
imperfection inherent in every human being. Thus, I
redesigned it based on your history to more accurately reflect
the varying grotesqueries of your nature. However, I was again
frustrated by failure."</span>, <span class="number">20</span>);</code></pre>
            <div class="next"><a href="php6.html">Следующая лекция</a></div><br>
</div>
<div id="vis">
    <div class="font">
        Размер шрифта:</div>
    <div class="fontA" onclick="fonta()">А</div>
    <div class="fontAA" onclick="fontaa()">А</div>
    <div class="fontAAA" onclick="fontaaa()">А</div>
    <div class="color">Цвет сайта:</div>
    <div class="colorW" onclick="clwhite()">A</div>
    <div class="colorBK" onclick="clblack()">A</div>
    <div class="colorBE" onclick="clblue()">A</div>
    <div class="imgOnOff">Изображение:</div>
    <div class="imgOn" onclick="imgon()">Вкл.</div>
    <div class="imgOff" onclick="imgoff()">Выкл.</div>
    <div id="exit" onclick="clc()" title="Закрыть">Обычная версия</div>
</div>