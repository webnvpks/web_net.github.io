<title>PHP Кэширование</title>
<link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="../../css/css.css">
<meta charset="utf-8">
<script src="../../js/jquery-3.3.1.min.js"></script>
<script src="../../js/vision_js.js"></script><script src="../../js/slide_js.js"></script>
<div class="body">
  <p class="vision" title="Версия для слабовидящих" onclick="cl()">
    <svg width="50" height="50" viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
      <path fill="#ffffff"
        d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
      </path>
    </svg>
  </p>
</div>
<div class="header"></div>
<div class="hat"><div class="sandwich" onclick="OpenMenu()">>>></div>
  <p class="name">
    Проектирование, разработка и оптимизация веб-приложений
  </p>
  <div class="links">
    <a href="../../../index.html" class="link">Главная</a>
    <a href="../lectures.html" class="link" title="Лекции">Лекции</a>
    <a href="../video.html" class="link" title="Видео-уроки">Видео-уроки</a>
    <a href="../laboratornie.html" class="link" title="Лабораторные работы">Лабораторные работы</a>
    <a href="../tests.html" class="link" title="Тесты">Тесты</a>
  </div>
</div>
<div class="content">
  <h1>Кэширование в PHP</h1>
  <h2>Введение</h2>
  <p>В старые добрые времена, когда создание web-сайтов представляло из себя
    такое простое занятие, как набор нескольких <em>HTML</em>-страниц,
    отправка web-страниц в браузер была простой отправкой файла web-сервером.
    Посетители сайта могли видеть эти небольшие, исключительно текстовые
    странички, почти мгновенно (если не считать пользователей медленных
    модемов). Как только страница была загружена, браузер кэширует её
    где-нибудь на локальном компьютере, чтобы в случае повторного запроса
    страницы, можно было взять его локальную версию из кэша, послав лишь
    короткий запрос, чтобы убедиться, что страница на сервере не была
    изменена. Запросы обрабатывались быстро и как можно эффективней, и все
    были счастливы (кроме использующих модемы 9600 бод).</p>
  <p>Появление динамических web-страниц изменило положение вещей в худшую
    сторону, эффективно «сломав» эту модель обслуживания web-страниц благодаря
    наличию двух проблем:</p>
  <ol>
    <li>Когда сервером получен запрос динамической web-странички,
      производится некоторая промежуточная обработка, например синтаксический
      анализ (парсинг) скрипта движком <em>PHP</em>, которая должна быть
      завершена. Благодаря этому получаем задержку перед тем, как web-сервер
      начнёт отправку вывода в браузер. Для простого <em>PHP</em>-скрипта это
      не существенно, но для более сложного приложения движок <em>PHP</em>
      может выполнить много действий прежде чем страница будет готова для
      отправки. Эти дополнительные действия приводят к заметной задержке между
      запросами пользователей и реальным отображением страниц в их браузерах.
    </li>
    <li>Типичный web-сервер, например Apache, использует время модификации
      файла чтобы правильно сообщить web-браузеру состояние кэша запрашиваемой
      странички. Для динамических web-страниц, фактически <em>PHP</em>-скрипт
      может изменяться только изредка, в то время как отображаемый им контент,
      возможно располагающийся в базе данных, изменяется часто. Web-сервер не
      имеет возможности знать о наличии изменений в базе данных, тем не менее
      он не отправляет дату последней модификации. Если клиент (браузер) не
      получает никакого признака того, как долго данные являются корректными,
      он предполагает, что в следующий раз необходимо запросить страничку по
      новой. Web-сервер всегда будет отвечать обновлённой версией странички,
      независимо от того, изменились ли данные. Чтобы избежать этого
      недостатка большинство web-разработчиков используют мета-тэги или
      <em>HTTP</em>-заголовки, чтобы сообщить браузеру никогда не использовать
      кэшированную версию странички. Однако это отрицает естественную
      способность web-браузера кэшировать web-страницы и обладает некоторыми
      существенными недостатками. Например, содержание динамической странички
      может изменяться раз в сутки, поэтому выгода, получаемая от наличия даже
      24-часового кэширования странички браузером, очевидна. </li>
  </ol>
  <p>Обычно для маленьких PHP-приложений вполне можно игнорировать
    существование этих проблем, однако с увеличением сложности и повышением
    трафика Вашего сайта Вы можете столкнуться с проблемами. Тем не менее, обе
    эти проблемы могут быть решены, первая путём кэширования на стороне
    сервера, вторая путём управления кэшированием на стороне клиента из вашего
    приложения. Подход, который вы будете использовать для решения проблем,
    будет зависеть от вашей области применения, но в этой главе мы увидим, как
    вы можете решить обе проблемы используя PHP и некоторые классы библиотеки
    <em>PEAR</em>.</p>

  <h2>Как я предотвращаю кэширование страницы браузерами?</h2>
  <p>Прежде чем мы рассмотрим методы клиентского и серверного кэширования, в
    первую очередь мы должны понять, как вообще предотвратить кэширование
    страниц web-браузером (и прокси-серверами). Основной способ достижения
    этого использует мета-тэги HTML:</p>
  <pre> &lt;meta http-equiv="Expires" content="Mon, 26 Jul 1997 05:00:00 GMT" /&gt;
 &lt;meta http-equiv="Pragma" content="no-cache" /&gt;
</pre>
  <p>Вставив прошедшую дату в мета-тэг Expires, вы сообщаете браузеру, что
    кэшированная копия странички всегда является устаревшей. Это значит, что
    браузер никогда не должен кэшировать страницу. Мета-тэг <strong>Pragma:
      no-cache</strong> довольно хорошо поддерживаемое соглашение, которому
    следует большинство web-браузеров. Обнаружив этот тэг, они обычно не
    кэшируют страницу (хотя никаких гарантий нет, это всего лишь
    соглашение).</p>
  <p>Это хорошо звучит, но есть две проблемы, связанные с использованием
    мета-тэгов:</p>
  <ol>
    <li>Если тэг не существовал когда страница была запрошена браузером
      впервые, но появляется позже (например, вы модифицировали включаемый
      файл <strong>pageheader.php</strong> который является шапкой
      каждой web-страницы), браузер останется в блаженном неведении и
      воспользуется свей кэшированной копей оригинала.
    </li>
    <li>Прокси-серверы, кэширующие web-страницы, как например общий
      <em>ISP</em>, вообще не будет исследовать непосредственно содержимое
      <em>HTML</em>-документа. Вместо этого они полагаются только на
      web-сервер, с которого пришли документы, и протокол <em>HTTP</em></a>. Иными
      словами, web-браузер может считать, что не должен кэшировать страницу,
      но прокси-сервер между браузером и вашим web-сервером вероятно не знает
      этого – и продолжит отправлять клиенту ту же самую, уже устаревшую,
      страницу. </li>
  </ol>
  <p>Лучший подход состоит в том, чтобы использовать непосредственно
    протокол <em>HTTP</em> с помощью функции PHP <b>header()</a></b>,
    эквивалентно приведённым выше двум мета-тэгам:</p>
  <pre class="adb"><code class="language-php">header(<span class="string">'Expires: Mon, 26 Jul 1997 05:00:00 GMT'</span>);
header(<span class="string">'Pragma: no-cache'</span>);</code></pre>
  <p>Мы можем пойти на один шаг вперёд, воспользовавшись заголовком
    <strong>Cache-Control</strong>&nbsp;&nbsp;совместимым с браузерами,
    поддерживающими <em>HTTP</em> 1.1:</p>
  <pre class="adb"><code class="language-php">header(<span class="string">'Expires: Mon, 26 Jul 1997 05:00:00 GMT'</span>);
header(<span class="string">'Cache-Control: no-store, no-cache, must-revalidate'</span>);
header(<span class="string">'Cache-Control: post-check=0, pre-check=0'</span>, <span class="keyword">FALSE</span>);
header(<span class="string">'Pragma: no-cache'</span>);</code></pre>
  <p>Это гарантирует, что никакой web-браузер или промежуточный
    прокси-сервер не будет кэшировать страницу, таким образом посетители
    всегда получат самую последнюю версию контента. Фактически, первый
    заголовок должен быть самодостаточным, это лучший способ гарантировать,
    что страница не кэшируется. Заголовки <strong>Cache-Control</strong> и
    <strong>Pragma</strong> добавлены с целью «подстраховаться». Хотя они не
    работают во всех браузерах или прокси, они отловят некоторые случаи, в
    которых <strong>Expires</strong> не работает должным образом (например,
    если дата на компьютере клиента установлена неправильно).</p>
  <p>Конечно, полный отказ от кэширования обеспечивает нас проблемами,
    которые мы обсуждали в начале этой главы. Сейчас мы рассмотрим решение
    этих проблем.</p>
  <h3>Internet Explorer и кэширование загрузки файлов</h3>
  <p>Если при обслуживании загрузки
    файла <em>PHP</em>-скриптом используются такие заголовки, как например
    <strong>Content-Disposition: attachment, filename=myFile.pdf</strong> или
    <strong>Content-Disposition: inline,
      filename=myFile.pdf</strong> у вас будут проблемы с
    <em>Internet Explorer</em>’ом, если вы сообщите браузеру не кэшировать
    страницу.</p>
  <p><em>Internet Explorer</em> оперирует загрузкой довольно необычным
    образом, выполняя два запроса к web-сайту. Первый запрос загружает файл и
    сохраняет его в кэше, пока не будет создан второй запрос (без сохранения
    отклика). Этот запрос вызывает процесс передачи файла конечному
    пользователю в соответствии с типом файла (например, запускает <em>Acrobat
      Reader</em>, если файл является <em>PDF</em>-документом). Это значит, что
    если вы отправили заголовки, запрещающие браузеру кэшировать страницу,
    <em>Internet Explorer</em> удалит файл между первым и вторым запросом, в
    результате чего конечный пользователь ничего не получит. Если файл,
    который вы отдаёте <em>PHP</em>-скриптом, не изменяется, одним из
    простейших решений будет убрать «запрещающие кэширование» заголовки из
    скрипта.</p>
  <p>Если загружаемый файл регулярно изменяется (т.е. вы хотите, чтобы
    браузер загружал новейшую версию), вы должны использовать заголовок
    <strong>Last-Modified</strong>, который будет рассмотрен в этой
    главе позднее, и гарантировать, что время модификации между двумя
    последовательными запросами не изменяется. Вы должны сделать это таким
    образом, чтобы не повлиять на пользователей браузеров, правильно
    оперирующих загрузкой. Одним из решений в этом случае будет сохранение
    файла на вашем web-сервере и предоставление простой ссылку к нему,
    предоставив web-серверу сообщать за вас заголовки кэширования. Конечно,
    это решение не может быть приемлемым, если предполагается авторизованный
    доступ к файлу, это решение допускает непосредственную загрузку
    сохранённого файла.</p>
  <h2>Как я могу захватить данные на стороне сервера для кэширования?</h2>
  <p>Пришло время взглянуть на то, как мы можем уменьшить задержку при
    помощи кэширования вывода на стороне сервера. Общий подход начинает
    предоставлять страницу как обычно, выполняя запросы к базе данных и так
    далее на <em>PHP</em>. Тем не менее, перед отправкой результата в браузер,
    мы захватываем его и сохраняем готовую страницу, например, в файле. При
    следующем запросе, <em>PHP</em>-скрипт сначала проверяет наличие
    кэшированной версии страницы. Если она существует, скрипт отправляет в
    браузер версию из кэша, исключая таким образом задержку на повторное
    создание страницы.</p>

  <h3>Несколько слов о кэшировании при помощи шаблонов</h3>
  <p>Шаблонные движки</a> часто говорят о кэшировании шаблонов. Обычно эти
    движки предлагают встроенный механизм для сохранения откомпилированной
    версии шаблона (т.е. генерируют из шаблона <em>PHP</em>-исходник), что
    предохраняет нас от необходимости парсить шаблон каждый раз, когда
    запрашивается страница. Это не нужно путать с кэшированием вывода, которое
    имеет отношение к кэшированию предоставляемого <em>HTML</em> (или другого
    вывода), который посылает <em>PHP</em> в браузер. Вы можете успешно
    использовать оба типа кэширования одновременно на одном и том же
    сайте.</p>
  <p>Сейчас мы рассмотрим встроенный механизм кэширования на <em>PHP</em>,
    использующий буферизацию вывода, который может использоваться вами
    независимо от способа создания контента (с шаблонами или без шаблонов).
    Рассмотрим ситуацию в которой ваш скрипт отображает результат использую, к
    примеру, <strong>echo</a></strong> или <strong>print</a></strong>, чтобы выдать
    данные непосредственно в браузер. В таком случае вы можете использовать
    функции управления выводом <em>PHP</em> для хранения данных в буферной
    памяти, над которой ваш <em>PHP</em>-скрипт имеет и доступ, и
    контроль.</p>
  <h5>Пример 1. Файл: 1.php</h5>
  <pre class="adb"><code class="language-html php"><span class="comment">// Начинаем буферизацию вывода</span>
ob_start();

<span class="comment">// Выводим некоторый текст (который сохраняется в буфере);</span>
<span class="keyword">echo</span> <span class="string">'1. Выводим это в буфер&lt;br /&gt;'</span>;

<span class="comment">// Получаем содержимое буфера</span>
<span class="variable">$buffer</span> = ob_get_contents();

<span class="comment">// Останавливаем буферизацию и очищаем буфер вывода</span>
ob_end_clean();

<span class="comment">// Выводим некоторый текст обычным образом</span>
<span class="keyword">echo</span> <span class="string">'2. Нормальный вывод&lt;br /&gt;'</span>;

<span class="comment">// Вывод содержимого буфера</span>
<span class="keyword">echo</span> <span class="variable">$buffer</span>;</code></pre>

  <p>Сам буфер хранит вывод как строку. Так, в вышеприведённом скрипте мы
    начинаем буферизацию с ob_start()</a>
    и используем <strong>echo</a></strong>, чтобы
    вывести что-либо. Затем мы используем ob_get_contents()</a>,
    чтобы выбрать данные, помещённые в буфер оператором <strong>echo</strong>,
    и сохранить их в строке. Функция ob_end_clean()</a> останавливает буферизацию вывода и
    уничтожает его содержимое, как альтернативу можно использовать ob_end_flush()</a>, чтобы
    вывести содержимое буфера.</p>

  <p>Другими словами, мы захватили вывод первого <strong>echo</strong>,
    затем послали его браузеру после второго <strong>echo</strong>. Как видно
    из этого простого примера, буферизация вывода является очень мощным
    инструментом для формирования вашего сайта, она обеспечивает решение для
    кэширования, как мы скоро увидим, и является отличным способом скрыть
    ошибки от посетителей вашего сайта (смотрите <a href="/php/php_error.php">Обработка ошибок</a>).
    Она также обеспечивает альтернативную возможность для переадресации
    браузера в ситуациях типа аутентификации пользователя.</p>
  <h3>Заголовки HTTP и буферизация вывода</h3>
  <p>Буферизация вывода может помочь решить наиболее общую проблему,
    связанную с функцией header()</a>, не говоря уже о
    <session_start()</a> и setcookie()</a>. Обычно, если вы вызываете любую из этих функций после того, как начался
      вывод страницы, вы получите противное сообщение об ошибке. При включенной буферизации вывода единственным типом
      вывода, избегающим буферизации, являются <em>HTTP</em>-заголовки. Используя <strong>ob_start()</a></strong> в
      самом начале выполнения вашего приложения, вы можете посылать заголовки в
      любой понравившейся точке программы, не сталкиваясь с обычными ошибками.
      Затем, как только вы будете уверены, что больше выводить
      <em>HTTP</em>-заголовки не потребуется, вы можете сразу же вывести
      содержимое страницы из буфера.</p>

  <h3>Использование буферизации вывода для кэширования на стороне
    сервера</h3>
  <p>Вы уже видели базовый пример буферизации вывода, теперь следующий шаг,
    в котором буфер сохраняется в файл:</p>

  <h5>Пример 2. Файл: 2.php</h5>
  <pre class="adb"><code class="language-php"><span class="comment">// Если существует кэшированная версия:</span>
  <span class="keyword">if</span> (file_exists(<span class="string">'./cache/2.cache'</span>)) {
    <span class="comment">// Читаем и выводим файл</span>
    readfile(<span class="string">'./cache/2.cache'</span>);
    <span class="keyword">exit</span>();
  }

  <span class="comment">// Начинаем буферизацию вывода</span>
  ob_start();

  <span class="comment">// Выводим остальной HTML</span>
<span class="preprocessor">?&gt;</span>
&lt;!DOCTYPE html <span class="keyword">PUBLIC</span> <span class="string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;
&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;
&lt;head&gt;
&lt;title&gt;Кэшированная страница&lt;/title&gt;
&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span> /&gt;
&lt;/head&gt;
&lt;body&gt;
Эта страница кэшируется средствами PHP
&lt;a href=<span class="string">"http://www.php.net/outcontrol"</span>&gt;Функции управления выводом&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?
  <span class="comment">// Получаем содержимое буфера</span>
  <span class="variable">$buffer</span> = ob_get_contents();

  <span class="comment">// Останов буферирования и вывод буфера</span>
  ob_end_flush();

  <span class="comment">// Сохранение кэш-файла с контентом</span>
  <span class="variable">$fp</span> = fopen(<span class="string">'./cache/2.cache'</span>, <span class="string">'w'</span>);
  fwrite(<span class="variable">$fp</span>, <span class="variable">$buffer</span>);
  fclose(<span class="variable">$fp</span>);
<span class="preprocessor">?&gt;</span></code></pre>

  <p>Сначала вышеописанный скрипт проверяет наличие существования версии
    странички в кэше, и, если она имеется, скрипт читает и выводит её. В
    противном случае, он использует буферизацию вывода для создания версии
    страницы в кэше. Она сохраняется как файл, после использования
    ob_end_flush()</a> для отображения страницы пользователю.</p>
  <p>Файл 2.cache содержит точную копию <em>HTML</em>, которую предоставляет скрипт:</p>
  <pre class="adb"><code class="language-html xml"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Кэшированная страница<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
Эта страница кэшируется средствами PHP
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://www.php.net/outcontrol"</span>&gt;</span>Функции управления выводом<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></code></pre>

  <h3>Блочная буферизация</h3>
  <p>Упрощённый подход кэширует выводимый буфер как одну страницу. Однако
    этот подход лишает вас реальных возможностей, предоставляемых функциями
    управления выводом <em>PHP</em>, улучшающих производительность вашего
    сайта методом соответственно различающихся сроков жизни вашего
    контента.</p>
  <p>Вне всякого сомнения, некоторые части отправляемой вами посетителю
    страницы изменяются очень редко, например, такие как шапку, меню и нижний
    колонтитул. Однако другие части, типа таблиц, содержащих обсуждения в
    форуме, могут изменяться довольно часто. Буферизация вывода может
    использоваться к кэшированию разделов страницы в отдельных файлах, затем
    создавать из них страницу – решение, устраняющее необходимость повторных
    запросов к базе данных, циклов while и т.д. Вы можете назначать каждому блоку страницы
    дату истечения срока, после которой пересоздаётся кэш-файл, или кроме
    того, вы можете включить в ваше приложение механизм, который будет удалять
    кэш-файл каждый раз, когда сохранённый в нём контент изменён.</p>
  <p>Вот пример, демонстрирующий этот принцип:</p>

  <h5>Пример 3. Файл: 3.php</h5>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">/* Запись кэш-файла
*<span class="phpdoc"> @param</span> string contents - содержание буфера
*<span class="phpdoc"> @param</span> string filename - имя файла, используемое при создании кэш-файла
*<span class="phpdoc"> @return</span> void
*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">writeCache</span><span class="params">(<span class="variable">$content</span>, <span class="variable">$filename</span>)</span> {</span>
  <span class="variable">$fp</span> = fopen(<span class="string">'./cache/'</span> . <span class="variable">$filename</span>, <span class="string">'w'</span>);
  fwrite(<span class="variable">$fp</span>, <span class="variable">$content</span>);
  fclose(<span class="variable">$fp</span>);
}

<span class="comment">/* Проверка кэш-файлов
*<span class="phpdoc"> @param</span> string filename - имя проверяемого кэш-файла
*<span class="phpdoc"> @param</span> int expiry - максимальный "возраст" файла в секундах
*<span class="phpdoc"> @return</span> mixed содержимое кэша или false
*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">readCache</span><span class="params">(<span class="variable">$filename</span>, <span class="variable">$expiry</span>)</span> {</span>
  <span class="keyword">if</span> (file_exists(<span class="string">'./cache/'</span> . <span class="variable">$filename</span>)) {
    <span class="keyword">if</span> ((time() - <span class="variable">$expiry</span>) &gt; filemtime(<span class="string">'./cache/'</span> . <span class="variable">$filename</span>))
      <span class="keyword">return</span> <span class="keyword">FALSE</span>;
    <span class="variable">$cache</span> = file(<span class="string">'./cache/'</span> . <span class="variable">$filename</span>);
    <span class="keyword">return</span> implode(<span class="string">''</span>, <span class="variable">$cache</span>);
  }
  <span class="keyword">return</span> <span class="keyword">FALSE</span>;
}
<span class="preprocessor">?&gt;</span></code></pre>

  <p>Первые две определённые нами функции, <strong>writeCache</strong> и
    <strong>readCache</strong>, используются соответственно для создания
    кэш-файлов и проверки их существования. Функция
    <strong>writeCache</strong> получает данные для кэширования в первом
    аргументе, и имя файла, используемое при создании кэш-файла. Функция
    <strong>readCache</strong> получает имя кэш-файла в первом параметре,
    вместе со временем в секундах, после которого кэш-файл должен считаться
    устаревшим. Если она сочтёт кэш-файл допустимым, скрипт вернёт его
    содержимое, в противном случае он вернёт <strong>FALSE</strong>, чтобы
    показать, что-либо кэш-файла не существует, либо он устарел.</p>
  <p>В этом примере я использовал процедурный подход. Однако я не советую
    делать это на практике, поскольку это закончится очень грязным кодом
    (смотри последующие решения с лучшей альтернативой) и, вероятно, вызовет
    проблемы с блокировкой файла (например, что случится, когда кто-то
    обращается к кэшу в момент его обновления?).</p>
  <p>Давайте продолжим этот пример. После того, как запущена буферизация
    вывода, начинается обработка. Сначала скрипт вызывает
    <strong>readCache</strong>, чтобы узнать, существует ли файл
    <strong>3_header.cache</strong>, он содержит шапку страницы – заголовок
    <em>HTML</em> и начало тела. Мы используем функцию date()</a> чтобы
    вывести время, когда страница фактически была сгенерирована, таким образом
    вы увидите различные кэш-файлы в работе, когда страница будет
    отображена.</p>

  <h5>Пример 4. Файл: 3.php</h5>
  <pre class="adb"><code class="language-php">&lt;?
  <span class="comment">// Начинаем буферизацию вывода</span>
  ob_start();

  <span class="comment">// Обработка шапки</span>
  <span class="keyword">if</span> (!<span class="variable">$header</span> = readCache(<span class="string">'3_header.cache'</span>, <span class="number">604800</span>)) {
    <span class="comment">// Вывод шапки</span>
<span class="preprocessor">?&gt;</span>

&lt;!DOCTYPE html <span class="keyword">PUBLIC</span> <span class="string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;
&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;
&lt;head&gt;
&lt;title&gt;Страница, кэшированная поблочно&lt;/title&gt;
&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span> /&gt;
&lt;/head&gt;
&lt;body&gt;
Время создания шапки: &amp;lt;?=date(<span class="string">'H:i:s'</span>); <span class="preprocessor">?&gt;</span> &lt;br /&gt;
&lt;?
    <span class="variable">$header</span> = ob_get_contents();
    ob_clean();
    writeCache(<span class="variable">$header</span>,<span class="string">'3_header.cache'</span>);
  }
<span class="preprocessor">?&gt;</span></code></pre>
  <p>Что же случается когда кэш-файл не найден? Выводится некоторый контент
    и присваивается переменной при помощи ob_get_contents()</a>,
    после чего буфер очищается функцией ob_clean()</a>.
    Это позволяет нам перехватывать вывод по
    частям и сопоставлять их с индивидуальными кэш-файлами при помощи
    <strong>writeCache</strong>. Заголовок страницы теперь хранится как файл,
    который может быть использован без нашего вмешательства в пересборку
    страницы. Давайте вернёмся на секунду к началу условного оператора. Когда
    мы вызывали <strong>readCache</strong>, мы передали ей время жизни кэша в
    604800 секунд (одна неделя), <strong>readCache</strong> использует время
    модификации кэш-файла, чтобы определить, является ли кэш-файл всё ещё
    допустимым.</p>
  <p>Для содержимого (тела) страницы мы по прежнему будем использовать тот
    же процесс. Однако на сей раз при вызове <strong>readCache</strong> мы
    будем использовать время жизни кэша в пять секунд, кэш-файл будет
    модифицироваться каждый раз, когда он «старше» 5 секунд:</p>

  <h5>Пример 5. Файл: 3.php</h5>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">// Обработка тела страницы</span>
<span class="keyword">if</span> (!<span class="variable">$body</span> = readCache(<span class="string">'3_body.cache'</span>, <span class="number">5</span>)) {
  <span class="keyword">echo</span> <span class="string">'Время создания тела: '</span> . date(<span class="string">'H:i:s'</span>) . <span class="string">'&lt;br /&gt;'</span>;
  <span class="variable">$body</span> = ob_get_contents();
  ob_clean();
  writeCache(<span class="variable">$body</span>, <span class="string">'3_body.cache'</span>);
}
<span class="preprocessor">?&gt;</span></code></pre>

  <p>Нижний колонтитул эффективно изменять так же, как заголовок. После
    этого буферизация вывода останавливается и отображается содержимое трёх
    переменных, содержащих данные страницы:</p>
  <h5>Пример 6. Файл: 3.php (окончание)</h5>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">// Обработка нижнего колонтитула страницы</span>
  <span class="keyword">if</span> (!<span class="variable">$footer</span> = readCache(<span class="string">'3_footer.cache'</span>, <span class="number">604800</span>)) {
<span class="preprocessor">?&gt;</span>

Время создания нижнего колонтитула: &amp;lt;?=date(<span class="string">'H:i:s'</span>); <span class="preprocessor">?&gt;</span> &lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;?
    <span class="variable">$footer</span> = ob_get_contents();
    ob_clean();
    writeCache(<span class="variable">$footer</span>, <span class="string">'3_footer.cache'</span>);
  }
  <span class="comment">// останавливаем буферизацию</span>
  ob_end_clean();

  <span class="comment">// Выводим содержимое страницы</span>
  <span class="keyword">echo</span> <span class="variable">$header</span> . <span class="variable">$body</span> . <span class="variable">$footer</span>;
<span class="preprocessor">?&gt;</span></code></pre>

  <p>Заголовок и нижний колонтитул обновляются еженедельно, в время как тело
    модифицируется, когда оно старее 5 секунд.</p>
  <p>Блок-схема на рисунке суммирует методологию блочной буферизации.</p>
  <p class="img"><img alt="Блок-схема блочной буферизации вывода" src="php12_pic1.gif" width="300px"><br>Блок-схема блочной буферизации вывода</p>

  <h3>Вложенные буферы</h3>
  <p>Вы можете вкладывать один буфер в другой фактически до
    бесконечности, просто вызвав <strong>ob_start()</strong></a> неоднократно. Это
    может быть полезным, если у вас имеется множество операций, использующих
    буфер вывода, например, одни перехватывают сообщения <em>PHP</em> об
    ошибках, другие имеют дело с кэшированием. Вы должны удостовериться, что
    <strong>ob_end_flush()</strong></a> или
    <strong>ob_end_clean()</strong></a> вызываются
    каждый раз, когда используется <strong>ob_start()</strong></a>.</p>

  <h2>Как мне управлять кэшированием на стороне клиента средствами PHP?</h2>
  <p>Пришло время посмотреть на механизм, который позволит нам
    контролировать кеш на стороне клиента средствами <em>PHP</em>. Этот подход
    будет работать только если вы используете <em>PHP</em> в связке с сервером
    <em>Apache</em>, поскольку мы будем использовать функцию getallheaders()</a>, чтобы
    получить заголовки, передаваемые браузером.
    Эта функция работает только в <em>Apache</em>.</p>
  <p><em>Новые имена функций</em></p>
  <p><em>Если вы используете <em>PHP</em> 4.3.0 с <em>Apache</em>,
      HTTP-заголовки доступны функцией <apache_request_headers()</a> и apache_response_headers()</a>. Функция
        getallheaders()</a> стала псевдонимом для новой функции apache_request_headers()</a>. </em> </p> <p>Механизмом
        для работы с кэшем web-браузера вновь является
        <em>HTTP</em>. Множество заголовков вовлечёны в инструктирование
        web-браузеров и прокси-серверов независимо кэшировать страницу, ситуация
        осложняется тем фактом, что некоторые из них доступны только с
        <em>HTTP</em> 1.1.</p>
  <p><em>Проверка HTTP-заголовков в вашем браузере</em></p>
  <p><em>Простым но очень удобным инструментом для проверки заголовков
      запросов и откликов является <em>LiveHttpHeaders</em> – аддон к браузеру
      <em>Mozilla</em>. Необходимо точно знать, какие заголовки посылает ваш
      скрипт, особенно когда вы имеете дело с заголовками кэширования
      <em>HTTP</em>.</em></p>
  <p>Для простоты мы рассмотрим только заголовки кэширования HTTP 1.0, а
    именно <strong>Expires</strong>, <strong>Last-Modified</strong> и
    <strong>If-Modified-Since</strong>, а также статус-код <strong>HTTP 304
      (Not Modified)</strong>.</p>
  <p>Другие заголовки, доступные с <em>HTTP</em> 1.1, например
    <strong>Cache-Control</strong> и <strong>ETag</strong>, предназначены для
    обеспечения расширенного механизма, который может использоваться совместно
    с состоянием web-сессии, иными словами, версия данной страницы,
    отображаемой неавторизованному посетителю, может значительно отличаться от
    отображаемой авторизованному пользователю. Заголовки <em>HTTP</em> 1.1
    изначально добавлялись для того, чтобы позволить кэшировать такие
    страницы.</p>
  <h3>Истечение срока жизни страницы</h3>
  <p>Самым простым в использовании заголовком является заголовок
    <strong>Expire</strong>, который устанавливает дату (возможно, будущую),
    когда страница устареет. До этого момента web-браузеру разрешается
    использовать кэшированную версию страницы.</p>

  <h5>Пример 7. 6.php</h5>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">/**
* Посылает заголовок Expires HTTP 1.0.
*<span class="phpdoc"> @param</span> int $expires - количество секунд до времени истечения срока жизни
*/</span>
<span class="function"><span class="keyword">function</span> <span class="title">setExpires</span><span class="params">(<span class="variable">$expires</span>)</span>{</span>
  header(<span class="string">'Expires: '</span> .
&nbsp;&nbsp;&nbsp;&nbsp;gmdate(<span class="string">'D, d M Y H:i:s'</span>, time() + <span class="variable">$expires</span>) . <span class="string">'GMT'</span>);
}

<span class="comment">// Устанавливаем заголовок времени истечения срока жизни Expires</span>
setExpires(<span class="number">10</span>);

<span class="comment">// Отображаем</span>
<span class="keyword">echo</span> <span class="string">'Эта страница самоуничтожится через 10 секунд&amp;lt;br /&amp;gt;'</span>;
<span class="keyword">echo</span> <span class="string">'Сейчас '</span> . gmdate(<span class="string">'H:i:s'</span>) . <span class="string">' GMT&amp;lt;br /&amp;gt;'</span>;
<span class="keyword">echo</span> <span class="string">'&amp;lt;a href="'</span> . <span class="variable">$_SERVER</span>[<span class="string">'PHP_SELF'</span>] .
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">'"&amp;gt;Посмотреть вновь &amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;'</span>;
<span class="preprocessor">?&gt;</span></code></pre>
  <p>Функция <strong>setExpires</strong> отправляет заголовок <em>HTTP</em>
    <strong>Expires</strong> с будущим временем, заданном в секундах.
    Вышеприведённый пример показывает текущее время по Гринвичу и выводит
    ссылку, которая вам позволяет перейти на страницу вновь. Используя кнопку
    Refresh вашего браузера, вы можете сообщить браузеру о желании обновить
    кэш. Используя ссылку, вы увидите, что время изменяется только раз в 10
    секунд.</p>
  <p><em>Даты и время в HTTP</em></p>
  <p><em>Даты в HTTP всегда вычисляются относительного меридиана времени
      Гринвича (GMT). Функция PHP gmdate()</a> точно такая же функция, как
      date()</a>, за исключением того,
      что она автоматически компенсирует время по Гринвичу, основанное на
      системных часах и настройках региона вашего сервера.</em></p>
  <p>Когда браузер сталкивается с заголовком <strong>Expires</strong>, он
    кэширует страницу. Все последующие запросы страницы, сделанные до
    указанного времени истечения срока жизни, используют версию страницы из
    кэша, никаких запросов к web-серверу при этом не происходит.</p>
  <p>Заголовок <strong>Expires</strong> преимущественно прост в реализации,
    но в большинстве случаев, если вы не высокоорганизованный человек, вы не
    можете знать точно, когда данная страница вашего сайта обновлена.
    Поскольку браузер войдёт в контакт с сервером только после того, как
    страница устареет, нет ни одного способа сообщить браузеру, что страница,
    находящаяся в его кэше, устарела. Вы также теряете некоторую часть трафика
    к вашему web-сайту, поскольку браузер не обращается к серверу при запросе
    страницы из кэша.</p>

  <h3>Время изменения страницы</h3>
  <p>Более практично использовать заголовки <strong>Last-Modified</strong> и
    <strong>If-Modified-Since</strong>, доступные в <em>HTTP</em> 1.0.
    Технически он известно как выполнение условного GET-запроса, вы
    возвращаете любой контент, основываясь на условии пришедшего заголовка
    запроса <strong>If-Modified-Since</strong>.</p>
  <p>При использовании этого метода вы должны отправлять заголовок
    <strong>Last-Modified</strong> каждый раз, когда обращаются к вашему
    PHP-скрипту. При следующем запросе страницы браузером, он отправит
    заголовок <strong>If-Modified-Since</strong>, содержащий время, по
    которому ваш скрипт может определить, обновлялась ли страница со времени
    последнего запроса. Если это не так, ваш скрипт посылает код статуса
    <strong>HTTP 304</strong>, чтобы указать, что страница не изменялась, не
    выводя при этом содержимого страницы.</p>
  <p>Устанавливаем время модификации кэш-файла этой строкой:</p>
  <pre
    class="adb"><code class="language-php"><span class="variable">$lastModified</span> = filemtime(<span class="variable">$cache_file</span>);</code></pre>
  <p>Затем, используя время модификации кэш-файла, мы посылаем заголовок
    <strong>Last-Modified</strong>. Нам нужно посылать её для каждой
    предоставляемой страницы, чтобы вынудить браузер посылать нам заголовок
    <strong>If-Modified-Since</strong> с каждым запросом.</p>
  <pre
    class="adb"><code class="language-php"><span class="comment">// Выдаём заголовок HTTP Last-Modified</span>
header(<span class="string">'Last-Modified: '</span> .
&nbsp;&nbsp;&nbsp;&nbsp;gmdate(<span class="string">'D, d M Y H:i:s'</span>, <span class="variable">$lastModified</span>) . <span class="string">' GMT'</span>);</code></pre>
  <p>Использование функции getallheaders()</a>
    обеспечивает нам получение от <em>PHP</em>
    всех входящих заголовков в виде массива. Затем мы должны проверить, что
    заголовок <strong>If-Modified-Since</strong> действительно существует,
    если он есть, мы должны обработать специальный случай старых версий
    <em>Mozilla</em> (ниже 6й версии), который добавлял в конец дополнительное поле к заголовку
    <strong>If-Modified-Since</strong>. Используя функцию <em>PHP</em>
    strtotime()</a>, мы получаем
    таймштамп даты, переданной нам браузером. Если такого заголовка нет, мы
    присваиваем таймштампу ноль, вынуждая таким образом <em>PHP</em> отдать
    посетителю последнюю версию страницы.</p>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">// Получаем заголовки запроса клиента - только для Apache</span>
<span class="variable">$request</span> = getallheaders();

<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$request</span>[<span class="string">'If-Modified-Since'</span>])) {
  <span class="comment">// Разделяем If-Modified-Since (Netscape &amp;lt; v6 отдаёт их неправильно)</span>
   <span class="variable">$modifiedSince</span> = explode(<span class="string">';'</span>, <span class="variable">$request</span>[<span class="string">'If-Modified-Since'</span>]);

   <span class="comment">// Преобразуем запрос клиента If-Modified-Since в таймштамп</span>
   <span class="variable">$modifiedSince</span> = strtotime(<span class="variable">$modifiedSince</span>[<span class="number">0</span>]);
} <span class="keyword">else</span> {
  <span class="comment">// Устанавливаем время модификации в ноль</span>
   <span class="variable">$modifiedSince</span> = <span class="number">0</span>;
}
<span class="preprocessor">?&gt;</span></code></pre>
  <p>Наконец, мы проверяем, был ли модифицирован кэш с тех пор как
    посетитель получал эту страницу в последний раз. Если это не так, мы
    просто посылаем в заголовке отклик <strong>Not Modified</strong> и
    прекращаем выполнение скрипта, не нагружая канал передачи данных и экономя
    процессорное время, инструктируя браузер отобразить кэшированную версию
    страницы.</p>
  <pre class="adb"><code class="language-php">&lt;?
<span class="comment">// Сравниваем время последней модификации контента с кэшем клиента</span>
<span class="keyword">if</span> (<span class="variable">$lastModified</span> &lt;= <span class="variable">$modifiedSince</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Разгружаем канал передачи данных!</span>
&nbsp;&nbsp;&nbsp;&nbsp;header(<span class="string">'HTTP/1.1 304 Not Modified'</span>);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">exit</span>();
}
<span class="preprocessor">?&gt;</span></code></pre>
  <a name="LastModified"></a>
  <p>И в заключение готовый кусок кода, позволяющий кешировать все статические ваши страницы.</p>
  <p>
    <strong>index.php</strong> - через него загружаются все файлы с сервера.
    Настройка сделана с помощью <a style="color:blue" href="php14.php">.htaccess</a>
  </p>
  <pre class="adb"><code class="language-php">&lt;?
<span class="variable">$url&nbsp;&nbsp;&nbsp;&nbsp;</span>= <span class="variable">$_SERVER</span>[<span class="string">'REQUEST_URI'</span>];
<span class="keyword">if</span>(<span class="variable">$url</span>==<span class="string">""</span>||<span class="variable">$url</span>==<span class="string">"/"</span>)
   <span class="variable">$url</span>=<span class="string">"index.htm"</span> ;
<span class="keyword">else</span> <span class="variable">$url</span>=substr(<span class="variable">$url</span>, <span class="number">1</span>);

<span class="keyword">if</span> ( !file_exists( <span class="variable">$url</span> ) )
&nbsp;&nbsp;&nbsp;&nbsp;{ header(<span class="string">"HTTP/1.0 404 Not Found"</span>); <span class="keyword">exit</span>();}

<span class="comment">// Получаем время последней модификации кэш-файла</span>
<span class="variable">$lastModified</span> = max(filemtime(<span class="variable">$url</span>),filemtime(<span class="string">'index.php'</span>));
<span class="variable">$slastModified</span> = gmdate(<span class="string">'D, d M Y H:i:s'</span>, <span class="variable">$lastModified</span>) . <span class="string">' GMT'</span>;
<span class="comment">// Выдаём заголовок HTTP Last-Modified</span>
header(<span class="string">'Last-Modified: '</span> . <span class="variable">$slastModified</span> );
<span class="comment">// Получаем заголовки запроса клиента - только для Apache</span>
<span class="variable">$headers</span> = getallheaders();
<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$headers</span>[<span class="string">'If-Modified-Since'</span>])) {
   <span class="comment">// Разделяем If-Modified-Since (Netscape &lt; v6 отдаёт их неправильно)</span>
   <span class="variable">$modifiedSince</span> = explode(<span class="string">';'</span>, <span class="variable">$headers</span>[<span class="string">'If-Modified-Since'</span>]);
   <span class="comment">// Преобразуем запрос клиента If-Modified-Since в таймштамп</span>
   <span class="variable">$modifiedSince</span> = strtotime(<span class="variable">$modifiedSince</span>[<span class="number">0</span>]);
   <span class="comment">// Сравниваем время последней модификации контента с кэшем клиента</span>
   <span class="keyword">if</span> (<span class="variable">$lastModified</span> &lt;= <span class="variable">$modifiedSince</span>)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Разгружаем канал передачи данных!</span>
&nbsp;&nbsp;&nbsp;&nbsp;{ header(<span class="string">'HTTP/1.1 304 Not Modified'</span>); <span class="keyword">exit</span>(); }
   }
<span class="keyword">echo</span> <span class="string">"&lt;DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"&gt;\n&lt;HTML&gt;\n"</span>;
<span class="keyword">echo</span> <span class="string">"&lt;HEAD&gt;\n"</span>;
<span class="keyword">echo</span> <span class="string">"&lt;META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=utf-8\"&gt;\n"</span>;
<span class="keyword">echo</span> <span class="string">"&lt;meta http-equiv=\"Last-Modified\" content=\""</span>.<span class="variable">$slastModified</span>.<span class="string">"\"&amp;gt;\n"</span>;
<span class="preprocessor">?&gt;</span></code></pre>
  <p>Если вы объедините подход времени последнего изменения со значением
    времени, являющимся уже доступным в вашем приложении (например, время
    самой последней новостной статьи, или время устаревания из системы
    серверного кэширования, которое мы видели в последнем решении), вы сможете
    воспользоваться преимуществами кэша web-браузера и разгрузите канал
    передачи данных, по возможности сэкономив информационный трафик с вашего
    сайта и улучшив его производительность.</p>
  <p>Будьте осторожны при тестировании любого кэширования, выполненного в
    таком стиле, если вы сделаете это неправильно, вы можете заставить ваших
    посетителей всегда иметь устаревшие копии вашего сайта.</p>


  <h2>Кэширование ваших страниц в 5 шагов</h2>
  <p>Кэширование ваших страниц может
    оказаться красивым и полезным механизмом, особенно, если они
    генерируются средствами PHP и делают множество SQL запросов. Как только
    вы примените кэширование, ваш сервер тут же снизит нагрузку и перестанет
    съедать много памяти на генерацию страниц - он просто будет загружать их
    из КЭШа. Я покажу вам, как PHP может кэшировать страницы и, в
    дальнейшем, вы сможете тратить на это минут 5.</p>

  <p>Расмотрим технологию кэширования пошагам:</p>
  <ol>
    <li>В домашней директории создаем файлы <strong>.htaccess</strong>,
      <strong>start_cache.php</strong>, <strong>end_cache.php</strong>, а
      также папку с названием <strong>cache_files</strong>.<br></li>
    <li>Папке <strong>cache_files</strong> необходимо проставить атрибуты <strong>777</strong>.<br> <br></li>
    <li>Внутри <strong>.htaccess</strong> файла пропишите следующие строки:

      <pre>php_value auto_prepend_file
		/home/username/public_html/start_cache.php
php_value auto_append_file
		/home/username/public_html/end_cache.php
</pre>
      Строку <em>/home/username/public_html/</em> необходимо заменить на путь к вашей домашней директории.<br>
      <br></li>

    <li>В скрипт <strong>start_cache.php</strong> помещаем следующий код:
      <pre>&lt;?php
// раздел настроек, которые вы можете менять
$settings_cachedir = '/home/username/public_html/cache_files/';
$settings_cachetime = 3600; //время жизни кэша (1 час)

// код
$thispage = 'http://' .
	$_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
$cachelink = $settings_cachedir.md5($thispage).".html";
if (file_exists($cachelink)) {
    $cachelink_time = filemtime($cachelink);

    if ((time() - $settings_cachetime) &lt; $cachelink_time) {
        readfile($cachelink);die();
    }
}

ob_start();
?&gt;
</pre>
      Не забывайте исправлять путь <em>/home/username/public_html/</em> на путь к вашей домашней директории.<br>
      <br></li>

    <li>А следующий код поместите в скрипт <strong>end_cache.php</strong>:
      <pre>&lt;?php
$fp = fopen($cachelink, 'w');
fwrite($fp, ob_get_contents());
fclose($fp);
ob_end_flush();
?&gt;
</pre>
    </li>
  </ol>

  <p>Все ваши страницы будут кэшироваться на 3600 секунд = 1 час. Этот параметр вы легко можете поменять в скрипте
    <strong>
      start_cache.php</strong>. Кэш страниц будет сохранен в папке <strong>
      cache_files</strong>.</p>

  <p>Совершенно очевидно, что в данном случае атрибуты <strong>777</strong>
    являются определенным нарушением безопасности. В связи с чем, рекомендую
    вынести папку <strong>cahce_files</strong> за пределы <strong>
      public_html</strong>, например, поместить ее на один уровень выше. Это
    закроет доступ к находящимся в ней файлам пользователей вашего сайта, но
    никак не повлияет на работоспособность системы.</p>
  <p>Также, у данного метода есть еще один серьезный недостаток: автор
    статьи складывает весь кэш в одну папку, что, при достаточном количестве
    страниц на вашем сайте, вызовет проблему, например, в системах Unix
    наблюдается достаточное замедление работоспособности при наличие в папке
    более чем 1000 файлов. В связи с чем, в алгоритм необходимо внести ряд
    изменений и раскладывать файлы по отдельным подпапкам внутри папки
    <strong>cache_files</strong>. Например, используя для этого первые 3-4
    символа md5 КЭШа.</p>
  <p>Для динамических ресурсов вполне возможно выбрать время кэширования в
    несколько (5-10) секунд или 1-2 минуты, что уже значительно снизит
    нагрузку на сервер, но не нанесет вреда интерактивности сайта.</p>

  <p>Для страниц, для которых особо важна интерактивность, можно ввести
    исключения в <strong><a style="color:blue;" href="php14.php">.htaccess</a></strong>, что позволит именно им
    постоянно изменяться, а для остальных страниц можно применять кэширование.</p>

  <h2>Регенерация содержания на лету</h2>

  <p>Динамически созданные, но статически обслуживаемые страницы,
    т.е. страницы которые должны передаваться как чисто статические
    (считываемые из файловой системы и затем передаваемые по запросу),
    однако они должны быть динамически сгенерированны веб-сервером если они отсутствуют в файловой системе.
    Таким образом вы можете иметь страницы сгенерированные PHP которые являются статически обслуживаемыми
    если только кто-либо (либо планировщик) не удалит статическое содержание. В таком случае содержание обновляется.</p>
  <p>Это делается следующим набором директив:</p>
  <pre>    RewriteCond %{REQUEST_FILENAME}   !-s
    RewriteRule ^page\.html$          page.php   [T=application/x-httpd-php,L]
</pre>
  <p>Здесь, запрос к page.html приводит к внутреннему запуску соответствующего page.php,
    если page.html все-ещё отсутствует или имеет нулевой размер.
    Фокус здесь в том что page.php это обычный PHP скрипт который в дополнение к собственному выводу, записывает свой
    вывод в файл page.html.
    Запустив это один раз, сервер передает данные page.html.
    Когда вебмастер хочет обновить содержание, он просто удаляет page.html (обычно с помощью cronjob).</p>

  <h2>Проблема с кэшированием страниц у Internet Explorer.</h2>

  <p>У IE при работе с заголовком "Vary" встречается одна неприятная ошибочка, связанная с кэшированием страниц.
    Проблема решается добавлением в .htaccess следующих строк:</p>
  <pre>BrowserMatch "MSIE" brokenvary=1
BrowserMatch "Mozilla/4.[0-9]{2}" brokenvary=1
BrowserMatch "Opera" !brokenvary
SetEnvIf brokenvary 1 force-no-vary
</pre>
  <div class="next"><a href="php13.html">Следующая лекция</a></div><br>
</div>
<div id="vis">
  <div class="font">
    Размер шрифта:</div>
  <div class="fontA" onclick="fonta()">А</div>
  <div class="fontAA" onclick="fontaa()">А</div>
  <div class="fontAAA" onclick="fontaaa()">А</div>
  <div class="color">Цвет сайта:</div>
  <div class="colorW" onclick="clwhite()">A</div>
  <div class="colorBK" onclick="clblack()">A</div>
  <div class="colorBE" onclick="clblue()">A</div>
  <div class="imgOnOff">Изображение:</div>
  <div class="imgOn" onclick="imgon()">Вкл.</div>
  <div class="imgOff" onclick="imgoff()">Выкл.</div>
  <div id="exit" onclick="clc()" title="Закрыть">Обычная версия</div>
</div>